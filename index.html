<!DOCTYPE html>
<html lang="ja" class="h-full bg-neutral-50">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BUILD_TAG=PHASE-5-20240529 | Muscle Routine</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    /* カラーパレット: 白・墨・淡い金 */
    :root {
      --color-sumi-dark: #1A1A1A;
      --color-sumi-mid: #404040;
      --color-sumi-light: #737373;
      --color-gold: #D4AF37;
      --color-gold-light: #E8D4A0;
      --color-gold-pale: #F5EDD6;
      --color-white: #FFFFFF;
      --color-off-white: #FAFAFA;
    }
    
    html, body { height: 100%; }
    body { 
      overflow-x: hidden;
      letter-spacing: 0.01em;
      line-height: 1.6;
    }
    
    :focus-visible { 
      outline: 2px solid var(--color-gold); 
      outline-offset: 2px; 
    }
    
    ::-webkit-scrollbar { width: 0; height: 0; }
    
    .ios-card { 
      border-radius: 20px; 
      box-shadow: 0 4px 16px -4px rgba(26, 26, 26, 0.08);
      transition: all 0.2s ease;
    }
    
    .ios-card:hover {
      box-shadow: 0 6px 20px -4px rgba(26, 26, 26, 0.12);
    }
    
    .section-card { 
      border-radius: 16px; 
      box-shadow: 0 2px 12px -2px rgba(26, 26, 26, 0.06);
      border: 1px solid rgba(115, 115, 115, 0.08);
    }
    
    .gold-accent {
      background: linear-gradient(135deg, var(--color-gold-pale) 0%, var(--color-white) 100%);
    }
    
    .sumi-text { color: var(--color-sumi-dark); }
    .sumi-text-mid { color: var(--color-sumi-mid); }
    .sumi-text-light { color: var(--color-sumi-light); }
  </style>
</head>
<body class="h-full sumi-text transition-colors duration-300">
  <div id="error-banner" class="hidden fixed top-0 left-0 right-0 z-50 flex items-center gap-2 bg-red-600 text-white px-4 py-3 shadow-lg">
    <span class="font-semibold">エラー</span>
    <span id="error-message" class="text-sm min-w-0 truncate"></span>
    <button type="button" id="error-dismiss" class="ml-auto text-xs font-semibold bg-white/15 hover:bg-white/25 rounded-full px-3 py-1 focus-visible:ring-2 focus-visible:ring-white/70 focus:outline-none min-h-[36px]">閉じる</button>
  </div>

  <main class="h-full max-w-3xl mx-auto px-4 pb-16 pt-20 flex flex-col gap-8 bg-transparent">
    <header class="space-y-2">
      <h1 class="text-3xl font-light tracking-wide sumi-text" style="letter-spacing: 0.05em;">筋トレ記録</h1>
      <p class="text-sm sumi-text-light font-light">自分の変化を美しく記録するツール</p>
    </header>

    <section data-route="#/dashboard" class="route-view hidden flex flex-col gap-6 bg-neutral-50"></section>
    <section data-route="#/today" class="route-view hidden flex flex-col gap-6 bg-violet-50"></section>
    <section data-route="#/exercise" class="route-view hidden flex flex-col gap-6 bg-orange-50"></section>
    <section data-route="#/set" class="route-view hidden flex flex-col gap-6 bg-orange-50"></section>
    <section data-route="#/history" class="route-view hidden flex flex-col gap-6 bg-amber-50"></section>
    <section data-route="#/settings" class="route-view hidden flex flex-col gap-6 bg-sky-50"></section>
  </main>

  <script>
    const state = {
      schemaVersion: 2,
      master: {
        parts: [
          { id: 'chest', label: '胸' },
          { id: 'back', label: '背中' },
          { id: 'shoulder', label: '肩' },
          { id: 'arm', label: '腕' },
          { id: 'leg', label: '脚' },
          { id: 'core', label: '体幹' },
          { id: 'full', label: '全身' }
        ],
        exercises: {
          chest: ['フライ', 'プレス', 'ベンチプレス', 'チェストプレス', 'ディップス', 'プッシュアップ'],
          back: ['チンニング', 'デッドリフト', 'ラットプルダウン', 'プーリーロー', 'ベントオーバーロー', 'ローイング', 'プルオーバー'],
          shoulder: ['ショルダープレス', 'フロントレイズ', 'サイドレイズ', 'リアデルト', 'リアレイズ', 'フェイスプル', 'アーノルドプレス', 'ミリタリープレス', 'パーシャルサイドレイズ'],
          arm: ['アームカール', 'スカルクラッシャー', 'ハンマーカール', 'プレスダウン', 'オーバーヘッドプレス', 'キックバック', 'リバースプッシュ', '志澤カール', 'スパイダーカール', 'ナロープレス', 'プリチャーカール'],
          leg: ['カール', 'エクステンション', 'プレス', 'スクワット', 'インナーサイ', 'アウターサイ', 'デッドリフト', 'ブルガリアン', 'ヒップスラスト'],
          core: ['クランチ', 'レッグレイズ', 'ベンチレッグレイズ'],
          full: []
        },
        gear: ['-', 'ケーブル', 'ダンベル', 'バーベル', 'スミス', 'マシン', 'ペックマシン', '自重', 'プレート', 'ゴムチューブ', 'イージーバー'],
        attachments: ['-', 'マグ(ナロー)', 'マグ(ワイド)', 'マグ(ミドル)', 'ロープ', 'Vバー', 'イージーバー', 'バンド', 'ワイドバー', 'ショートバー', 'パラレルバー'],
        angles: ['-', 'インクライン', 'デクライン', 'フラット'],
        positions: ['-', 'ワイド', 'ナロー', 'ボックス', 'リバース']
      },
      customMaster: {
        exercises: {},  // { chest: ['カスタム種目1', ...], ... }
        gear: [],
        attachments: [],
        angles: [],
        positions: []
      },
      history: [],
      day: {
        date: new Date().toISOString().slice(0, 10),
        memo: '',
        items: [
          {
            id: createId('item'),
            order: 1,
            mode: 'single',
            groupId: null,
            part: 'chest',
            exercise: 'バーベルベンチプレス',
            gear: 'バーベル',
            attachment: '-',
            angle: 'フラット',
            position: '-',
            timed: false,
            oneHand: false,
            sets: [
              createSet({ weight: 60, repsU: 10, repsA: 0, warmup: true, drop: false, round: null, ts: Date.now() - 7200000 }),
              createSet({ weight: 80, repsU: 8, repsA: 0, warmup: false, drop: false, round: null, ts: Date.now() - 7100000 }),
              createSet({ weight: 60, repsU: 12, repsA: 0, warmup: false, drop: true, round: null, ts: Date.now() - 7090000 })
            ]
          },
          ...createSampleSuperset()
        ]
      }
    };

    const uiState = {
      route: null,
      exerciseForm: createExerciseFormState(),
      currentItemId: null,
      setEditor: null,
      editingHistoryIndex: null
    };

    // セット編集中のアクティブな種目情報（自動保存用）
    let activeEditSession = null;

    function createId(prefix) {
      return `${prefix}-${Math.random().toString(36).slice(2, 11)}`;
    }

    function createSet({ weight = null, repsU = null, repsA = null, seconds = null, warmup = false, drop = false, round = null, ts = Date.now() }) {
      return { id: createId('set'), weight, repsU, repsA, seconds, warmup, drop, round, ts };
    }

    function createSampleSuperset() {
      const groupId = createGroupId();
      const now = Date.now();
      const baseTs = now - 3600000;
      const bench = {
        id: createId('item'),
        order: 2,
        mode: 'superset',
        groupId,
        part: 'chest',
        exercise: 'ダンベルフライ',
        gear: 'ダンベル',
        attachment: '-',
        angle: 'フラット',
        position: '-',
        timed: false,
        oneHand: false,
        sets: [
          createSet({ weight: 20, repsU: 12, repsA: 0, warmup: false, drop: false, round: 0, ts: baseTs }),
          createSet({ weight: 14, repsU: 12, repsA: 0, warmup: false, drop: true, round: 0, ts: baseTs + 1000 })
        ]
      };
      const pull = {
        id: createId('item'),
        order: 2.01,
        mode: 'superset',
        groupId,
        part: 'back',
        exercise: 'ラットプルダウン',
        gear: 'マシン',
        attachment: 'ワイドバー',
        angle: '-',
        position: '-',
        timed: false,
        oneHand: false,
        sets: [
          createSet({ weight: 55, repsU: 10, repsA: 0, warmup: false, drop: false, round: 0, ts: baseTs })
        ]
      };
      return [bench, pull];
    }

    function createGroupId() {
      return `grp_${Math.random().toString(36).slice(2, 8)}`;
    }

    function createExerciseFormState() {
      // LocalStorageから前回の設定を読み込む
      const saved = loadLastExerciseSettings();
      if (saved) {
        // 前のセットの部位を引き継ぐ
        const lastItem = state.day.items[state.day.items.length - 1];
        if (lastItem && lastItem.part) {
          saved.selectedParts = [lastItem.part];
        }
        return saved;
      }
      
      // 前のセットの部位を引き継ぐ
      const lastItem = state.day.items[state.day.items.length - 1];
      const selectedParts = lastItem && lastItem.part ? [lastItem.part] : [];
      
      return {
        superset: false,
        cards: [createExerciseCardState('A')],
        selectedParts: selectedParts
      };
    }
    
    function saveLastExerciseSettings(formState) {
      try {
        localStorage.setItem('lastExerciseSettings', JSON.stringify(formState));
      } catch (e) {
        console.error('Failed to save exercise settings:', e);
      }
    }
    
    function loadLastExerciseSettings() {
      try {
        const saved = localStorage.getItem('lastExerciseSettings');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (e) {
        console.error('Failed to load exercise settings:', e);
      }
      return null;
    }
    
    function clearLastExerciseSettings() {
      try {
        localStorage.removeItem('lastExerciseSettings');
      } catch (e) {
        console.error('Failed to clear exercise settings:', e);
      }
    }

    function createExerciseCardState(label) {
      const firstPart = state.master.parts[0]?.id ?? '';
      const firstExercise = (state.master.exercises[firstPart] || [])[0] || '';
      return {
        key: createId('card'),
        label,
        part: firstPart,
        exercise: firstExercise,
        gear: '-',
        attachment: '-',
        angle: '-',
        position: '-',
        timed: false,
        oneHand: false,
        dropset: false
      };
    }

    function sortForDisplay(list) {
      return [...list].sort((a, b) => {
        if (a === '-') return -1;
        if (b === '-') return 1;
        return a.localeCompare(b, 'ja');
      });
    }

    function showError(message) {
      const banner = document.getElementById('error-banner');
      const text = document.getElementById('error-message');
      text.textContent = message;
      banner.classList.remove('hidden');
    }

    window.onerror = function(message, source, lineno, colno) {
      showError(`${message} (${lineno}:${colno})`);
    };

    window.onunhandledrejection = function(event) {
      showError(event.reason ? event.reason.toString() : 'Unhandled rejection');
    };

    window.__forceError = function() {
      setTimeout(() => {
        throw new Error('強制エラー発生');
      }, 0);
      Promise.reject(new Error('強制エラー発生'));
    };

    document.getElementById('error-dismiss').addEventListener('click', () => {
      document.getElementById('error-banner').classList.add('hidden');
    });

    function navigate(hash) {
      if (window.location.hash === hash) {
        handleNavigation(hash);
      } else {
        window.location.hash = hash;
      }
    }

    function handleNavigation(hash) {
      const valid = ['#/dashboard', '#/today', '#/exercise', '#/set', '#/history', '#/settings'];
      const next = valid.includes(hash) ? hash : '#/dashboard';
      uiState.route = next;
      
      // bodyの背景色をルートに応じて変更
      const bgColors = {
        '#/dashboard': 'bg-neutral-50',
        '#/today': 'bg-violet-50',
        '#/exercise': 'bg-orange-50',
        '#/set': 'bg-orange-50',
        '#/history': 'bg-amber-50',
        '#/settings': 'bg-sky-50'
      };
      
      const body = document.body;
      // 既存の背景色クラスを削除
      Object.values(bgColors).forEach(cls => body.classList.remove(cls));
      // 新しい背景色クラスを追加
      body.classList.add(bgColors[next]);
      
      document.querySelectorAll('.route-view').forEach(section => {
        section.classList.toggle('hidden', section.getAttribute('data-route') !== next);
      });
      render();
    }

    window.addEventListener('hashchange', () => handleNavigation(window.location.hash));

    function render() {
      if (uiState.route === '#/dashboard') renderDashboard();
      if (uiState.route === '#/today') renderToday();
      if (uiState.route === '#/exercise') renderExercise();
      if (uiState.route === '#/set') renderSet();
      if (uiState.route === '#/history') renderHistory();
      if (uiState.route === '#/settings') renderSettings();
    }

    function renderDashboard() {
      const container = document.querySelector('[data-route="#/dashboard"]');
      container.innerHTML = '';

      // ナビゲーションボタン
      const navContainer = document.createElement('div');
      navContainer.className = 'space-y-3';
      
      // 今日のトレーニングボタン（全幅）
      const todayButton = document.createElement('button');
      todayButton.type = 'button';
      todayButton.className = 'ios-card bg-white w-full px-6 py-4 text-base font-light transition active:scale-[0.99] min-h-[44px] sumi-text hover:gold-accent border border-neutral-100';
      todayButton.innerHTML = `
        <div class="flex flex-col items-center gap-2">
          <span class="text-2xl">📝</span>
          <span>今日のトレーニング</span>
        </div>
      `;
      todayButton.addEventListener('click', () => navigate('#/today'));
      navContainer.appendChild(todayButton);
      
      // 履歴と設定ボタン（半分ずつ）
      const bottomRow = document.createElement('div');
      bottomRow.className = 'grid grid-cols-2 gap-3';
      
      const historyButton = document.createElement('button');
      historyButton.type = 'button';
      historyButton.className = 'ios-card bg-white w-full px-6 py-4 text-base font-light transition active:scale-[0.99] min-h-[44px] sumi-text hover:gold-accent border border-neutral-100';
      historyButton.innerHTML = `
        <div class="flex flex-col items-center gap-2">
          <span class="text-2xl">📖</span>
          <span>履歴</span>
        </div>
      `;
      historyButton.addEventListener('click', () => navigate('#/history'));
      bottomRow.appendChild(historyButton);
      
      const settingsButton = document.createElement('button');
      settingsButton.type = 'button';
      settingsButton.className = 'ios-card bg-white w-full px-6 py-4 text-base font-light transition active:scale-[0.99] min-h-[44px] sumi-text hover:gold-accent border border-neutral-100';
      settingsButton.innerHTML = `
        <div class="flex flex-col items-center gap-2">
          <span class="text-2xl">⚙️</span>
          <span>設定</span>
        </div>
      `;
      settingsButton.addEventListener('click', () => navigate('#/settings'));
      bottomRow.appendChild(settingsButton);
      
      navContainer.appendChild(bottomRow);
      container.appendChild(navContainer);

      // 統計情報カード
      const stats = computeDashboardStats();
      const statsCard = document.createElement('section');
      statsCard.className = 'section-card bg-white p-4 space-y-3';
      statsCard.innerHTML = `
        <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">統計情報</h2>
        <div class="grid grid-cols-3 gap-3 text-center">
          <div class="section-card gold-accent py-4 px-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs sumi-text-light font-light mb-1">今週</p>
            <p class="text-3xl font-light sumi-text">${stats.thisWeek}</p>
            <p class="text-xs sumi-text-light font-light mt-1">回</p>
          </div>
          <div class="section-card bg-neutral-50 py-4 px-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs sumi-text-light font-light mb-1">総日数</p>
            <p class="text-3xl font-light sumi-text">${stats.totalDays}</p>
            <p class="text-xs sumi-text-light font-light mt-1">日</p>
          </div>
          <div class="section-card bg-neutral-50 py-4 px-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs sumi-text-light font-light mb-1">最終日</p>
            <p class="text-lg font-light sumi-text">${stats.lastDate}</p>
          </div>
        </div>
      `;
      container.appendChild(statsCard);

      // グラフセクション（履歴がある場合のみ）
      if (state.history.length > 0) {
        // 部位別トレーニング頻度グラフ
        const bodyPartChartSection = document.createElement('section');
        bodyPartChartSection.className = 'section-card bg-white p-4 space-y-3';
        bodyPartChartSection.innerHTML = `
          <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">部位別トレーニング頻度</h2>
          <div style="height: 280px; position: relative;">
            <canvas id="bodyPartChart"></canvas>
          </div>
        `;
        container.appendChild(bodyPartChartSection);
        
        // 週間総ボリューム推移グラフ
        const weeklyVolumeSection = document.createElement('section');
        weeklyVolumeSection.className = 'section-card bg-white p-4 space-y-3';
        weeklyVolumeSection.innerHTML = `
          <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">週間総ボリューム推移</h2>
          <div style="height: 240px; position: relative;">
            <canvas id="weeklyVolumeChart"></canvas>
          </div>
        `;
        container.appendChild(weeklyVolumeSection);
        
        // 種目別進捗グラフ
        const exerciseNames = getAllExerciseNames();
        if (exerciseNames.length > 0) {
          const progressChartSection = document.createElement('section');
          progressChartSection.className = 'section-card bg-white p-4 space-y-3';
          
          const selectContainer = document.createElement('div');
          selectContainer.className = 'flex items-center justify-between gap-3';
          selectContainer.innerHTML = `
            <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">種目別進捗</h2>
            <select id="exerciseSelect" class="text-sm sumi-text bg-neutral-50 border border-neutral-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-violet-300">
              ${exerciseNames.map(name => `<option value="${name}">${name}</option>`).join('')}
            </select>
          `;
          progressChartSection.appendChild(selectContainer);
          
          const chartContainer = document.createElement('div');
          chartContainer.style.height = '240px';
          chartContainer.style.position = 'relative';
          chartContainer.innerHTML = '<canvas id="exerciseProgressChart"></canvas>';
          progressChartSection.appendChild(chartContainer);
          
          container.appendChild(progressChartSection);
          
          // 初期表示
          setTimeout(() => {
            renderExerciseProgressChart('exerciseProgressChart', exerciseNames[0]);
          }, 100);
          
          // 種目変更時のイベント
          document.getElementById('exerciseSelect')?.addEventListener('change', (e) => {
            renderExerciseProgressChart('exerciseProgressChart', e.target.value);
          });
          
          // 種目別ボリューム推移グラフ
          const volumeChartSection = document.createElement('section');
          volumeChartSection.className = 'section-card bg-white p-4 space-y-3';
          
          const volumeSelectContainer = document.createElement('div');
          volumeSelectContainer.className = 'flex items-center justify-between gap-3';
          volumeSelectContainer.innerHTML = `
            <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">種目別ボリューム推移</h2>
            <select id="exerciseVolumeSelect" class="text-sm sumi-text bg-neutral-50 border border-neutral-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-violet-300">
              ${exerciseNames.map(name => `<option value="${name}">${name}</option>`).join('')}
            </select>
          `;
          volumeChartSection.appendChild(volumeSelectContainer);
          
          const volumeChartContainer = document.createElement('div');
          volumeChartContainer.style.height = '240px';
          volumeChartContainer.style.position = 'relative';
          volumeChartContainer.innerHTML = '<canvas id="exerciseVolumeChart"></canvas>';
          volumeChartSection.appendChild(volumeChartContainer);
          
          container.appendChild(volumeChartSection);
          
          // 初期表示
          setTimeout(() => {
            renderExerciseVolumeChart('exerciseVolumeChart', exerciseNames[0]);
          }, 100);
          
          // 種目変更時のイベント
          document.getElementById('exerciseVolumeSelect')?.addEventListener('change', (e) => {
            renderExerciseVolumeChart('exerciseVolumeChart', e.target.value);
          });
        }
        
        // 部位別チャートを描画
        setTimeout(() => {
          renderBodyPartChart('bodyPartChart');
          renderWeeklyVolumeChart('weeklyVolumeChart');
        }, 100);
      }

      // 最近のトレーニング概要
      if (state.history.length > 0) {
        const recentSection = document.createElement('section');
        recentSection.className = 'section-card bg-white p-4 space-y-3';
        
        const header = document.createElement('div');
        header.className = 'flex items-center justify-between';
        header.innerHTML = `
          <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">最近のトレーニング</h2>
          <button type="button" class="text-sm sumi-text-light hover:sumi-text transition font-light" id="view-all-history">すべて見る →</button>
        `;
        recentSection.appendChild(header);
        
        const recentWorkouts = state.history.slice(0, 3);
        recentWorkouts.forEach((workout, index) => {
          const workoutCard = createRecentWorkoutCard(workout);
          recentSection.appendChild(workoutCard);
          if (index < recentWorkouts.length - 1) {
            const divider = document.createElement('div');
            divider.className = 'border-t border-neutral-100';
            recentSection.appendChild(divider);
          }
        });
        
        container.appendChild(recentSection);
        
        document.getElementById('view-all-history')?.addEventListener('click', () => navigate('#/history'));
      } else {
        // 履歴がない場合のメッセージ
        const emptyCard = document.createElement('section');
        emptyCard.className = 'section-card bg-white p-6 text-center';
        emptyCard.innerHTML = `
          <p class="text-base sumi-text-light font-light mb-4">まだトレーニング履歴がありません</p>
          <button type="button" class="ios-card gold-accent px-6 py-3 text-base font-light sumi-text transition active:scale-[0.99] min-h-[44px]" id="start-first-workout">最初のトレーニングを始める</button>
        `;
        container.appendChild(emptyCard);
        
        document.getElementById('start-first-workout')?.addEventListener('click', () => navigate('#/today'));
      }
    }

    function computeDashboardStats() {
      // 今週のトレーニング回数を計算
      const now = new Date();
      const startOfWeek = new Date(now);
      startOfWeek.setDate(now.getDate() - now.getDay()); // 日曜日を週の始まりとする
      startOfWeek.setHours(0, 0, 0, 0);
      
      const thisWeekCount = state.history.filter(workout => {
        const workoutDate = new Date(workout.date);
        return workoutDate >= startOfWeek;
      }).length;
      
      // 総トレーニング日数
      const totalDays = state.history.length;
      
      // 最後のトレーニング日付
      let lastDate = '-';
      if (state.history.length > 0) {
        const lastWorkout = state.history[0];
        const date = new Date(lastWorkout.date);
        lastDate = `${date.getMonth() + 1}/${date.getDate()}`;
      }
      
      return {
        thisWeek: thisWeekCount,
        totalDays,
        lastDate
      };
    }

    // グラフ用の統計データ処理関数
    function computeExerciseProgressData(exerciseName) {
      // 特定の種目の重量推移データを取得
      const data = [];
      
      // 履歴を古い順にソート
      const sortedHistory = [...state.history].reverse();
      
      sortedHistory.forEach(workout => {
        workout.items.forEach(item => {
          const fullExerciseName = buildFullExerciseName(item);
          if (fullExerciseName === exerciseName) {
            // この種目の最大重量を取得
            const maxWeight = Math.max(...item.sets.map(set => parseFloat(set.weight) || 0));
            if (maxWeight > 0) {
              const date = new Date(workout.date);
              data.push({
                date: `${date.getMonth() + 1}/${date.getDate()}`,
                weight: maxWeight
              });
            }
          }
        });
      });
      
      return data;
    }
    
    function computeBodyPartFrequency() {
      // 部位別のトレーニング頻度を集計
      const frequency = {};
      
      state.history.forEach(workout => {
        workout.items.forEach(item => {
          const part = state.master.parts.find(p => p.id === item.part);
          const partLabel = part ? part.label : item.part;
          frequency[partLabel] = (frequency[partLabel] || 0) + 1;
        });
      });
      
      return frequency;
    }
    
    function getAllExerciseNames() {
      // 全ての種目名を取得（重複なし）
      const exerciseNames = new Set();
      
      state.history.forEach(workout => {
        workout.items.forEach(item => {
          const fullName = buildFullExerciseName(item);
          exerciseNames.add(fullName);
        });
      });
      
      return Array.from(exerciseNames).sort();
    }
    
    function buildFullExerciseName(item) {
      // 種目の完全な名前を構築
      let name = '';
      
      // 部位
      const part = state.master.parts.find(p => p.id === item.part);
      if (part) name += part.label + ' - ';
      
      // 種目
      name += item.exercise;
      
      return name;
    }

    // ボリューム計算関数
    function computeExerciseVolume(item) {
      return item.sets.reduce((total, set) => {
        if (set.warmup) return total; // ウォームアップは除外
        const weight = parseFloat(set.weight) || 0;
        const reps = parseInt(set.reps) || 0;
        return total + (weight * reps);
      }, 0);
    }
    
    function computeSessionVolume(workout) {
      return workout.items.reduce((total, item) => {
        return total + computeExerciseVolume(item);
      }, 0);
    }
    
    function getWeekKey(date) {
      const d = new Date(date);
      const startOfWeek = new Date(d);
      startOfWeek.setDate(d.getDate() - d.getDay());
      startOfWeek.setHours(0, 0, 0, 0);
      
      const endOfWeek = new Date(startOfWeek);
      endOfWeek.setDate(startOfWeek.getDate() + 6);
      
      const startMonth = startOfWeek.getMonth() + 1;
      const startDay = startOfWeek.getDate();
      const endMonth = endOfWeek.getMonth() + 1;
      const endDay = endOfWeek.getDate();
      
      return `${startMonth}/${startDay}-${endMonth}/${endDay}`;
    }
    
    function computeWeeklyVolume() {
      const weeklyData = {};
      
      state.history.forEach(workout => {
        const weekKey = getWeekKey(workout.date);
        
        if (!weeklyData[weekKey]) {
          weeklyData[weekKey] = 0;
        }
        
        weeklyData[weekKey] += computeSessionVolume(workout);
      });
      
      return weeklyData;
    }
    
    function computeExerciseVolumeProgress(exerciseName) {
      const data = [];
      const sortedHistory = [...state.history].reverse();
      
      sortedHistory.forEach(workout => {
        workout.items.forEach(item => {
          const fullName = buildFullExerciseName(item);
          if (fullName === exerciseName) {
            const volume = computeExerciseVolume(item);
            if (volume > 0) {
              const date = new Date(workout.date);
              data.push({
                date: `${date.getMonth() + 1}/${date.getDate()}`,
                volume: volume
              });
            }
          }
        });
      });
      
      return data;
    }

    // グラフ描画関数
    function renderExerciseProgressChart(canvasId, exerciseName) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      
      const data = computeExerciseProgressData(exerciseName);
      if (data.length === 0) return;
      
      const ctx = canvas.getContext('2d');
      
      // 既存のチャートを破棄
      if (canvas.chart) {
        canvas.chart.destroy();
      }
      
      canvas.chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.map(d => d.date),
          datasets: [{
            label: '重量 (kg)',
            data: data.map(d => d.weight),
            borderColor: 'rgb(139, 92, 246)',
            backgroundColor: 'rgba(139, 92, 246, 0.1)',
            tension: 0.3,
            fill: true,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 26, 0.9)',
              titleColor: '#FFFFFF',
              bodyColor: '#FFFFFF',
              borderColor: 'rgb(212, 175, 55)',
              borderWidth: 1,
              padding: 12,
              displayColors: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(115, 115, 115, 0.1)'
              },
              ticks: {
                color: '#737373',
                font: {
                  size: 11
                }
              }
            },
            x: {
              grid: {
                display: false
              },
              ticks: {
                color: '#737373',
                font: {
                  size: 11
                }
              }
            }
          }
        }
      });
    }
    
    function renderBodyPartChart(canvasId) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      
      const frequency = computeBodyPartFrequency();
      const labels = Object.keys(frequency);
      const data = Object.values(frequency);
      
      if (labels.length === 0) return;
      
      const ctx = canvas.getContext('2d');
      
      // 既存のチャートを破棄
      if (canvas.chart) {
        canvas.chart.destroy();
      }
      
      const colors = [
        'rgb(139, 92, 246)',   // 紫
        'rgb(212, 175, 55)',   // 金
        'rgb(251, 146, 60)',   // オレンジ
        'rgb(59, 130, 246)',   // 青
        'rgb(236, 72, 153)',   // ピンク
        'rgb(34, 197, 94)',    // 緑
        'rgb(168, 85, 247)'    // 深紫
      ];
      
      canvas.chart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: colors.slice(0, labels.length),
            borderWidth: 2,
            borderColor: '#FFFFFF'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: '#404040',
                font: {
                  size: 12
                },
                padding: 12,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 26, 0.9)',
              titleColor: '#FFFFFF',
              bodyColor: '#FFFFFF',
              borderColor: 'rgb(212, 175, 55)',
              borderWidth: 1,
              padding: 12,
              displayColors: true,
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.parsed || 0;
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const percentage = ((value / total) * 100).toFixed(1);
                  return `${label}: ${value}回 (${percentage}%)`;
                }
              }
            }
          }
        }
      });
    }
    
    function renderWeeklyVolumeChart(canvasId) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      
      if (canvas.chart) {
        canvas.chart.destroy();
      }
      
      const weeklyData = computeWeeklyVolume();
      const labels = Object.keys(weeklyData);
      const data = Object.values(weeklyData);
      
      if (labels.length === 0) {
        return;
      }
      
      canvas.chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: '週間総ボリューム (kg)',
            data: data,
            backgroundColor: 'rgba(139, 92, 246, 0.8)',
            borderColor: 'rgb(139, 92, 246)',
            borderWidth: 2,
            borderRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#404040',
                font: {
                  size: 12,
                  weight: 'bold'
                },
                padding: 12,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 26, 0.9)',
              titleColor: '#FFFFFF',
              bodyColor: '#FFFFFF',
              borderColor: 'rgb(212, 175, 55)',
              borderWidth: 1,
              padding: 12,
              displayColors: true,
              callbacks: {
                label: function(context) {
                  return context.dataset.label + ': ' + context.parsed.y.toLocaleString() + ' kg';
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                color: '#404040',
                font: {
                  size: 11
                },
                callback: function(value) {
                  return value.toLocaleString() + ' kg';
                }
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            },
            x: {
              ticks: {
                color: '#404040',
                font: {
                  size: 11
                }
              },
              grid: {
                display: false
              }
            }
          }
        }
      });
    }
    
    function renderExerciseVolumeChart(canvasId, exerciseName) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      
      if (canvas.chart) {
        canvas.chart.destroy();
      }
      
      const progressData = computeExerciseVolumeProgress(exerciseName);
      
      if (progressData.length === 0) {
        return;
      }
      
      const labels = progressData.map(d => d.date);
      const data = progressData.map(d => d.volume);
      
      canvas.chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'ボリューム (kg)',
            data: data,
            borderColor: 'rgb(212, 175, 55)',
            backgroundColor: 'rgba(212, 175, 55, 0.1)',
            borderWidth: 3,
            fill: true,
            tension: 0.3,
            pointRadius: 5,
            pointHoverRadius: 7,
            pointBackgroundColor: 'rgb(212, 175, 55)',
            pointBorderColor: '#FFFFFF',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#404040',
                font: {
                  size: 12,
                  weight: 'bold'
                },
                padding: 12,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 26, 0.9)',
              titleColor: '#FFFFFF',
              bodyColor: '#FFFFFF',
              borderColor: 'rgb(212, 175, 55)',
              borderWidth: 1,
              padding: 12,
              displayColors: true,
              callbacks: {
                label: function(context) {
                  return context.dataset.label + ': ' + context.parsed.y.toLocaleString() + ' kg';
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                color: '#404040',
                font: {
                  size: 11
                },
                callback: function(value) {
                  return value.toLocaleString() + ' kg';
                }
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            },
            x: {
              ticks: {
                color: '#404040',
                font: {
                  size: 11
                }
              },
              grid: {
                display: false
              }
            }
          }
        }
      });
    }

    function createRecentWorkoutCard(workout) {
      const card = document.createElement('div');
      card.className = 'py-3 space-y-2';
      
      const date = new Date(workout.date);
      const dateStr = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
      
      // 種目数とセット数を計算
      const exerciseCount = workout.items.length;
      const totalSets = workout.items.reduce((sum, item) => sum + item.sets.length, 0);
      
      // 部位を集計
      const parts = [...new Set(workout.items.map(item => {
        const part = state.master.parts.find(p => p.id === item.part);
        return part ? part.label : item.part;
      }))].join('、');
      
      card.innerHTML = `
        <div class="flex items-center justify-between">
          <p class="text-sm font-light sumi-text">${dateStr}</p>
          <p class="text-xs sumi-text-light font-light">${exerciseCount}種目 · ${totalSets}セット</p>
        </div>
        <p class="text-xs sumi-text-light font-light">${parts}</p>
      `;
      
      return card;
    }

    function computeTodayStats() {
      const singles = state.day.items
        .filter(item => item.mode === 'single')
        .flatMap(item => item.sets)
        .filter(set => !set.warmup)
        .length;
      const roundMap = new Map();
      state.day.items
        .filter(item => item.mode === 'superset' && item.groupId)
        .forEach(item => {
          if (!roundMap.has(item.groupId)) roundMap.set(item.groupId, new Map());
          const groupRounds = roundMap.get(item.groupId);
          item.sets.forEach(set => {
            if (set.round === null || set.round === undefined) return;
            if (!groupRounds.has(set.round)) groupRounds.set(set.round, { hasWorking: false });
            if (!set.warmup) {
              groupRounds.get(set.round).hasWorking = true;
            }
          });
        });
      let supersetRounds = 0;
      roundMap.forEach(group => {
        group.forEach(entry => {
          if (entry.hasWorking) supersetRounds += 1;
        });
      });
      return {
        soloSets: singles,
        supersetRounds,
        workSets: singles + supersetRounds
      };
    }

    function renderToday() {
      const container = document.querySelector('[data-route="#/today"]');
      container.innerHTML = '';

      // ヘッダー（タイトルとホームボタン）
      const header = document.createElement('div');
      header.className = 'flex items-center justify-between mb-3';
      const title = document.createElement('h1');
      title.className = 'text-lg font-light sumi-text';
      const isEditing = uiState.editingHistoryIndex !== null;
      title.textContent = isEditing ? '履歴を編集' : '今日のトレーニング';
      header.appendChild(title);
      const homeButton = document.createElement('button');
      homeButton.type = 'button';
      homeButton.className = 'flex items-center gap-1 text-sm font-light sumi-text-light hover:sumi-text transition min-h-[44px] px-3';
      homeButton.innerHTML = '← ホーム';
      homeButton.addEventListener('click', () => navigate('#/dashboard'));
      header.appendChild(homeButton);
      container.appendChild(header);

      const statsSection = document.createElement('section');
      statsSection.className = 'section-card bg-white p-4 space-y-2';
      const summary = computeTodayStats();
      statsSection.innerHTML = `
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.03em;">今日の概要</h2>
          <span class="text-xs font-light sumi-text-light">ウォームアップ除外</span>
        </div>
        <div class="grid grid-cols-3 gap-2 text-center">
          <div class="ios-card py-3 min-h-[44px] flex flex-col justify-center border" style="background-color: rgba(245, 237, 214, 0.15); border-color: rgba(212, 175, 55, 0.2); color: var(--color-gold);">
            <p class="text-xs font-light">作業セット</p>
            <p class="text-2xl font-light">${summary.workSets}</p>
          </div>
          <div class="ios-card py-3 min-h-[44px] flex flex-col justify-center border" style="background-color: rgba(245, 237, 214, 0.15); border-color: rgba(212, 175, 55, 0.2); color: var(--color-gold);">
            <p class="text-xs font-light">SSラウンド</p>
            <p class="text-2xl font-light">${summary.supersetRounds}</p>
          </div>
          <div class="ios-card py-3 min-h-[44px] flex flex-col justify-center border" style="background-color: rgba(245, 237, 214, 0.15); border-color: rgba(212, 175, 55, 0.2); color: var(--color-gold);">
            <p class="text-xs font-light">単独セット</p>
            <p class="text-2xl font-light">${summary.soloSets}</p>
          </div>
        </div>
      `;
      container.appendChild(statsSection);

      // メモ入力欄
      const memoSection = document.createElement('div');
      memoSection.className = 'section-card bg-white p-4 space-y-2';
      const memoLabel = document.createElement('label');
      memoLabel.className = 'text-xs font-light sumi-text-light';
      memoLabel.textContent = 'トレーニングメモ';
      const memoTextarea = document.createElement('textarea');
      memoTextarea.className = 'w-full p-3 text-sm sumi-text font-light border rounded-lg focus:outline-none focus:ring-2 focus:ring-gold/30 transition';
      memoTextarea.style.cssText = 'border-color: rgba(115, 115, 115, 0.2); background-color: rgba(245, 237, 214, 0.05); min-height: 80px; resize: vertical;';
      memoTextarea.placeholder = '今日のトレーニングのメモを記録...';
      memoTextarea.value = state.day.memo || '';
      memoTextarea.addEventListener('input', (e) => {
        state.day.memo = e.target.value;
        autoSaveDraft(); // 自動保存
      });
      memoSection.appendChild(memoLabel);
      memoSection.appendChild(memoTextarea);
      container.appendChild(memoSection);

      const actionRow = document.createElement('div');
      actionRow.className = 'flex items-center gap-3';
      const addButton = document.createElement('button');
      addButton.type = 'button';
      addButton.className = 'ios-card px-6 py-3 font-light text-base min-h-[44px] border transition';
      addButton.style.cssText = 'background-color: var(--color-gold); color: white; border-color: var(--color-gold-dark); letter-spacing: 0.05em; flex: 2;';
      addButton.textContent = '＋ 種目追加';
      addButton.addEventListener('click', () => {
        uiState.exerciseForm = createExerciseFormState();
        navigate('#/exercise');
      });
      actionRow.appendChild(addButton);
      
      const completeButton = document.createElement('button');
      completeButton.type = 'button';
      completeButton.className = 'ios-card px-6 py-3 font-light text-base min-h-[44px] border transition';
      completeButton.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em; flex: 1;';
      completeButton.textContent = isEditing ? '保存' : '完了';
      completeButton.addEventListener('click', () => {
        const message = isEditing ? '変更を保存しますか？' : '今日のトレーニングを完了しますか？';
        if (confirm(message)) {
          completeWorkout();
        }
      });
      actionRow.appendChild(completeButton);
      container.appendChild(actionRow);

      const list = document.createElement('div');
      list.className = 'space-y-3';
      const sortedItems = [...state.day.items].sort((a, b) => a.order - b.order);
      const processedGroups = new Set();
      sortedItems.forEach(item => {
        if (item.mode === 'superset') {
          if (!item.groupId || processedGroups.has(item.groupId)) return;
          const groupItems = sortedItems.filter(candidate => candidate.groupId === item.groupId);
          processedGroups.add(item.groupId);
          list.appendChild(buildSupersetCard(groupItems));
        } else {
          list.appendChild(buildSingleCard(item));
        }
      });
      container.appendChild(list);
    }

    function buildSingleCard(item) {
      const card = document.createElement('article');
      card.className = 'section-card bg-white p-4 space-y-2';
      const partLabel = state.master.parts.find(p => p.id === item.part)?.label ?? '';
      
      // ヘッダー：種目名と部位
      const header = document.createElement('div');
      header.className = 'space-y-1';
      header.innerHTML = `
        <p class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${item.exercise}</p>
        <p class="text-xs font-light sumi-text-light">${partLabel}</p>
      `;
      card.appendChild(header);
      
      // 器具・角度・ポジション
      const details = document.createElement('div');
      details.className = 'text-xs font-light sumi-text-light';
      details.textContent = [item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ');
      card.appendChild(details);
      if (item.attachment && item.attachment !== '-') {
        const att = document.createElement('p');
        att.className = 'text-[11px] font-light sumi-text-light';
        att.textContent = `アタッチメント: ${item.attachment}`;
        card.appendChild(att);
      }

      const badgeArea = document.createElement('div');
      badgeArea.className = 'flex flex-col gap-2';
      groupSetsForDisplay(item.sets).forEach(group => {
        const row = document.createElement('div');
        row.className = 'flex flex-col gap-1';
        const badgeRow = document.createElement('div');
        badgeRow.className = 'flex items-start gap-2';
        badgeRow.appendChild(createSetBadge(group.base, item));
        if (group.drops.length > 0) {
          const dropList = document.createElement('div');
          dropList.className = 'pl-6 flex flex-wrap gap-2';
          group.drops.forEach(drop => dropList.appendChild(createSetBadge(drop, item, true)));
          badgeRow.appendChild(dropList);
        }
        row.appendChild(badgeRow);
        if (group.base.memo) {
          const memoDiv = document.createElement('div');
          memoDiv.className = 'pl-1 text-[10px] font-light sumi-text-light';
          memoDiv.textContent = `メモ: ${group.base.memo}`;
          row.appendChild(memoDiv);
        }
        badgeArea.appendChild(row);
      });
      card.appendChild(badgeArea);

      const controls = document.createElement('div');
      controls.className = 'flex justify-end';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'px-4 py-2 rounded-full text-sm font-light min-h-[44px] border transition';
      editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
      editBtn.textContent = '編集';
      editBtn.addEventListener('click', () => {
        uiState.currentItemId = item.id;
        prepareSetEditor(item.id);
        navigate('#/set');
      });
      controls.appendChild(editBtn);
      card.appendChild(controls);
      return card;
    }

    function buildSupersetCard(groupItems) {
      const sorted = [...groupItems].sort((a, b) => a.order - b.order);
      const labels = ['A', 'B', 'C'];
      const title = `(SS) ${sorted.map(item => item.exercise).join(' + ')}`;
      const card = document.createElement('article');
      card.className = 'section-card bg-white p-4 space-y-2';
      
      // ヘッダー：種目名と部位
      const header = document.createElement('div');
      header.className = 'space-y-1';
      header.innerHTML = `
        <p class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${title}</p>
        <p class="text-xs font-light sumi-text-light">${sorted.map((item, index) => `${labels[index]}. ${state.master.parts.find(p => p.id === item.part)?.label ?? ''}`).join(' / ')}</p>
      `;
      card.appendChild(header);
      
      // 器具・角度・ポジション
      const details = document.createElement('div');
      details.className = 'text-xs font-light sumi-text-light';
      details.textContent = sorted.map(item => [item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ')).join(' ｜ ');
      card.appendChild(details);

      const rounds = buildSupersetRounds(sorted);
      if (rounds.length > 0) {
        const roundList = document.createElement('div');
        roundList.className = 'flex flex-col gap-2';
        rounds.forEach(round => {
          const row = document.createElement('div');
          row.className = 'flex flex-col gap-1';
          const badgeRow = document.createElement('div');
          badgeRow.className = 'flex flex-wrap gap-2 items-start';
          round.entries.forEach(entry => badgeRow.appendChild(entry));
          row.appendChild(badgeRow);
          if (round.drops.length > 0) {
            const dropRow = document.createElement('div');
            dropRow.className = 'pl-6 flex flex-wrap gap-2';
            round.drops.forEach(drop => dropRow.appendChild(drop));
            row.appendChild(dropRow);
          }
          roundList.appendChild(row);
        });
        card.appendChild(roundList);
      }

      const soloArea = document.createElement('div');
      const soloChips = [];
      sorted.forEach((item, index) => {
        const solos = groupSetsForDisplay(item.sets.filter(set => set.round == null));
        solos.forEach(group => {
          const row = document.createElement('div');
          row.className = 'flex items-start gap-2';
          const chip = createSetBadge(group.base, item);
          chip.textContent = `${labels[index]}: ${chip.textContent}`;
          row.appendChild(chip);
          if (group.drops.length > 0) {
            const dropList = document.createElement('div');
            dropList.className = 'pl-6 flex flex-wrap gap-2';
            group.drops.forEach(drop => dropList.appendChild(createSetBadge(drop, item, true)));
            row.appendChild(dropList);
          }
          soloChips.push(row);
        });
      });
      if (soloChips.length > 0) {
        const soloArea = document.createElement('div');
        soloArea.className = 'space-y-2 pt-2 border-t border-neutral-100';
        const soloList = document.createElement('div');
        soloList.className = 'space-y-2';
        soloChips.forEach(row => soloList.appendChild(row));
        soloArea.appendChild(soloList);
        card.appendChild(soloArea);
      }

      const controls = document.createElement('div');
      controls.className = 'flex justify-end gap-3 pt-1';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'px-4 py-2 rounded-full text-sm font-light min-h-[44px] border transition';
      editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
      editBtn.textContent = '編集';
      editBtn.addEventListener('click', () => {
        uiState.currentItemId = sorted[0].id;
        prepareSetEditor(sorted[0].id);
        navigate('#/set');
      });
      controls.appendChild(editBtn);
      card.appendChild(controls);
      return card;
    }

    function buildSupersetRounds(groupItems) {
      const map = new Map();
      const labels = ['A', 'B', 'C'];
      groupItems.forEach((item, index) => {
        let currentBase = null;
        item.sets
          .filter(set => set.round !== null && set.round !== undefined)
          .sort((a, b) => a.ts - b.ts)
          .forEach(set => {
            if (!map.has(set.round)) {
              map.set(set.round, { entries: new Map(), drops: [] });
            }
            const slot = map.get(set.round);
            if (!set.drop) {
              currentBase = { item, set };
              slot.entries.set(labels[index], { item, set, drops: [] });
            } else if (currentBase && slot.entries.has(labels[index])) {
              slot.entries.get(labels[index]).drops.push({ item, set });
            } else {
              slot.drops.push(createSetBadge(set, item, true));
            }
          });
      });
      const rows = [];
      [...map.keys()].sort((a, b) => a - b).forEach(round => {
        const entry = map.get(round);
        const displayEntries = [];
        const dropBadges = [...entry.drops];
        groupItems.forEach((item, index) => {
          const label = labels[index];
          const data = entry.entries.get(label);
          if (data) {
            const chip = createSetBadge(data.set, data.item);
            chip.textContent = `${label}: ${chip.textContent}`;
            displayEntries.push(chip);
            data.drops.forEach(drop => {
              dropBadges.push(createSetBadge(drop.set, drop.item, true));
            });
          }
        });
        if (displayEntries.length > 0) {
          rows.push({ entries: displayEntries, drops: dropBadges });
        }
      });
      return rows;
    }

    function groupSetsForDisplay(sets) {
      const rows = [];
      let current = null;
      sets.forEach(set => {
        if (!set.drop) {
          current = { base: set, drops: [] };
          rows.push(current);
        } else if (current) {
          current.drops.push(set);
        } else {
          rows.push({ base: set, drops: [] });
        }
      });
      return rows;
    }

    function createSetBadge(set, item, isDrop = false) {
      const badge = document.createElement('span');
      const baseClasses = 'inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold min-h-[32px] truncate';
      const color = set.warmup ? 'bg-slate-200 text-slate-600' : 'bg-orange-100 text-orange-700';
      badge.className = `${baseClasses} ${isDrop ? 'border border-orange-200 bg-orange-50 text-orange-600' : color}`;
      badge.textContent = formatSetValue(set, item.timed);
      return badge;
    }

    function formatSetValue(set, timed) {
      if (timed) {
        return `${set.seconds ?? '-'}秒`;
      }
      const weight = set.weight != null ? `${set.weight}kg` : '-kg';
      const reps = set.repsU != null ? `${set.repsU}` : '-';
      const assist = set.repsA != null && set.repsA > 0 ? ` +${set.repsA}` : '';
      return `${weight}×${reps}${assist}`;
    }

    function renderExercise() {
      const container = document.querySelector('[data-route="#/exercise"]');
      container.innerHTML = '';

      const form = document.createElement('form');
      form.className = 'section-card bg-white p-6 space-y-6';
      form.innerHTML = `
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-light sumi-text" style="letter-spacing: 0.05em;">種目入力</h2>
          <button type="button" id="exerciseBack" class="text-sm font-light px-3 py-2 min-h-[44px] transition" style="color: var(--color-gold);">← 戻る</button>
        </div>
        <div class="-mx-6 px-6 overflow-x-auto">
          <div id="partFilterButtons" class="flex gap-2 pb-2"></div>
        </div>
        <div class="flex items-center justify-between gap-3 rounded-2xl px-4 py-3 text-sm gold-accent border" style="border-color: rgba(212, 175, 55, 0.15);">
          <div class="flex items-center gap-3 sumi-text-mid">
            <input type="checkbox" id="supersetToggle" class="w-5 h-5 rounded" style="color: var(--color-gold);" ${uiState.exerciseForm.superset ? 'checked' : ''}>
            <label for="supersetToggle" class="font-light">スーパーセットにする</label>
          </div>
          <button type="button" id="resetForm" class="text-xs sumi-text-light hover:sumi-text font-light px-2 py-1 transition">リセット</button>
        </div>
        <div id="exercisePreview" class="hidden rounded-xl px-4 py-3 text-sm border" style="background-color: rgba(245, 237, 214, 0.3); border-color: rgba(212, 175, 55, 0.2);">
          <div class="flex items-start gap-2">
            <svg class="w-5 h-5 mt-0.5 flex-shrink-0" style="color: var(--color-gold);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <div class="flex-1">
              <div class="font-light sumi-text mb-1" style="letter-spacing: 0.02em;">入力中の種目</div>
              <div id="exercisePreviewText" class="sumi-text-mid font-light"></div>
            </div>
          </div>
        </div>
        <div id="exerciseCards" class="flex flex-col gap-4"></div>
        <div class="flex justify-between items-center">
          <button type="submit" class="ios-card text-white px-6 py-3 font-light min-h-[44px] transition" style="background-color: var(--color-gold); letter-spacing: 0.05em;">決定</button>
        </div>
      `;
      container.appendChild(form);

      const cardsContainer = form.querySelector('#exerciseCards');
      renderExerciseCards(cardsContainer);
      
      // 部位選択ボタンのレンダリング
      renderPartFilterButtons(form);

      // リセットボタンのイベント
      form.querySelector('#resetForm').addEventListener('click', () => {
        clearLastExerciseSettings();
        uiState.exerciseForm = {
          superset: false,
          cards: [createExerciseCardState('A')]
        };
        renderExercise();
      });
      
      // プレビュー更新関数
      function updateExercisePreview() {
        const preview = form.querySelector('#exercisePreview');
        const previewText = form.querySelector('#exercisePreviewText');
        const cards = uiState.exerciseForm.cards;
        
        if (cards.length === 0) {
          preview.classList.add('hidden');
          return;
        }
        
        const descriptions = cards.map((card, index) => {
          const partLabel = state.master.parts.find(p => p.id === card.part)?.label || card.part;
          const details = [card.exercise, card.gear !== '-' ? card.gear : null, card.attachment !== '-' ? card.attachment : null, card.angle !== '-' ? card.angle : null, card.position !== '-' ? card.position : null].filter(Boolean).join(' / ');
          const prefix = uiState.exerciseForm.superset ? `${['A', 'B', 'C'][index]}: ` : '';
          return `${prefix}${partLabel} - ${details}`;
        });
        
        previewText.innerHTML = descriptions.join('<br>');
        preview.classList.remove('hidden');
        
        // LocalStorageに保存
        saveLastExerciseSettings(uiState.exerciseForm);
      }

      form.addEventListener('change', event => {
        if (event.target.id === 'supersetToggle') {
          uiState.exerciseForm.superset = event.target.checked;
          if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length < 2) {
            uiState.exerciseForm.cards = [createExerciseCardState('A'), createExerciseCardState('B')];
          }
          if (!uiState.exerciseForm.superset) {
            uiState.exerciseForm.cards = [createExerciseCardState('A')];
          }
          renderExercise();
        }
        updateExercisePreview();
      });
      
      // 初回プレビュー表示
      updateExercisePreview();

      form.addEventListener('submit', event => {
        event.preventDefault();
        const newItems = buildItemsFromExerciseForm();
        const baseOrder = Math.max(0, ...state.day.items.map(item => item.order)) + 1;
        newItems.forEach((item, index) => {
          item.order = item.mode === 'superset' ? baseOrder + index * 0.01 : baseOrder;
          state.day.items.push(item);
        });
        state.day.items.sort((a, b) => a.order - b.order);
        const firstId = newItems[0]?.id;
        if (firstId) {
          uiState.currentItemId = firstId;
          prepareSetEditor(firstId, true);
          navigate('#/set');
        } else {
          navigate('#/today');
        }
      });

      form.querySelector('#exerciseBack').addEventListener('click', () => navigate('#/today'));
    }
    
    function renderPartFilterButtons(form) {
      const container = form.querySelector('#partFilterButtons');
      container.innerHTML = '';
      
      // 選択中の部位を初期化（存在しない場合）
      if (!uiState.exerciseForm.selectedParts) {
        uiState.exerciseForm.selectedParts = [];
      }
      
      state.master.parts.forEach(part => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'px-4 py-2 rounded-full text-sm font-light min-h-[40px] border transition whitespace-nowrap';
        
        const isSelected = uiState.exerciseForm.selectedParts.includes(part.id);
        if (isSelected) {
          button.style.cssText = 'background-color: var(--color-gold); color: white; border-color: var(--color-gold-dark); letter-spacing: 0.05em;';
        } else {
          button.style.cssText = 'background-color: white; color: var(--color-sumi); border-color: rgba(115, 115, 115, 0.2); letter-spacing: 0.05em;';
        }
        
        button.textContent = part.label;
        button.addEventListener('click', () => {
          togglePartFilter(part.id);
          renderPartFilterButtons(form);
          
          // 部位ドロップダウンも更新
          if (uiState.exerciseForm.selectedParts.length === 1) {
            // 部位が1つだけ選択されている場合、その部位をカードに設定
            uiState.exerciseForm.cards.forEach(card => {
              card.part = uiState.exerciseForm.selectedParts[0];
            });
          }
          
          // 種目ドロップダウンを更新
          const cardsContainer = form.querySelector('#exerciseCards');
          renderExerciseCards(cardsContainer);
        });
        
        container.appendChild(button);
      });
    }
    
    function togglePartFilter(partId) {
      if (!uiState.exerciseForm.selectedParts) {
        uiState.exerciseForm.selectedParts = [];
      }
      
      const index = uiState.exerciseForm.selectedParts.indexOf(partId);
      if (index > -1) {
        uiState.exerciseForm.selectedParts.splice(index, 1);
      } else {
        uiState.exerciseForm.selectedParts.push(partId);
      }
    }

    function renderExerciseCards(container) {
      container.innerHTML = '';
      uiState.exerciseForm.cards.forEach((card, index) => {
        const cardEl = document.createElement('section');
        cardEl.className = 'bg-white rounded-2xl p-4 space-y-3 border border-neutral-200/40 shadow-sm';
        const label = uiState.exerciseForm.superset ? ['A', 'B', 'C'][index] : '';
        const title = uiState.exerciseForm.superset ? `${label} 種目` : '種目設定';
        cardEl.innerHTML = `
          <div class="flex items-center justify-between mb-1">
            <h3 class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${title}</h3>
            ${uiState.exerciseForm.superset && uiState.exerciseForm.cards.length > 2 && index === uiState.exerciseForm.cards.length - 1
              ? '<button type="button" class="text-xs sumi-text-light hover:sumi-text font-light transition" data-remove="true">削除</button>'
              : ''}
          </div>
          
          <!-- 基本情報 -->
          <div class="space-y-2 pb-2 border-b border-neutral-200/30">
            <div class="flex items-center gap-1.5">
              <div class="w-0.5 h-3 rounded-full" style="background-color: var(--color-gold);"></div>
              <h4 class="text-xs font-light sumi-text-mid" style="letter-spacing: 0.05em;">基本情報</h4>
            </div>
            <div class="flex flex-col gap-2">
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid flex items-center gap-0.5">
                  種目<span style="color: var(--color-gold);">*</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="exercise"></select>
              </label>
            </div>
          </div>
          
          <!-- 器具設定 -->
          <div class="space-y-2 py-2 border-b border-neutral-200/30">
            <div class="flex items-center gap-1.5">
              <div class="w-0.5 h-3 rounded-full" style="background-color: var(--color-gold-light);"></div>
              <h4 class="text-xs font-light sumi-text-mid" style="letter-spacing: 0.05em;">器具</h4>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid">
                  器具 <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="gear"></select>
              </label>
              <label class="flex flex-col gap-1" data-attachment-field>
                <span class="text-xs font-light sumi-text-mid">
                  アタッチメント <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="attachment"></select>
              </label>
            </div>
            <div class="text-[10px] sumi-text-light pl-0.5 font-light" data-attachment-hint>ケーブル/マシン時に設定</div>
          </div>
          
          <!-- 詳細設定 -->
          <div class="space-y-2 pt-2">
            <div class="flex items-center gap-1.5">
              <div class="w-0.5 h-3 rounded-full" style="background-color: var(--color-gold-pale);"></div>
              <h4 class="text-xs font-light sumi-text-mid" style="letter-spacing: 0.05em;">詳細</h4>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid">
                  角度 <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="angle"></select>
              </label>
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid">
                  ポジション <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="position"></select>
              </label>
            </div>
            <div class="flex flex-wrap gap-2 text-xs pt-1">
              <label class="flex items-center gap-1.5 rounded-lg px-3 py-1.5 border cursor-pointer transition" style="border-color: rgba(115, 115, 115, 0.15); background-color: rgba(245, 237, 214, 0.1);">
                <input type="checkbox" class="w-3.5 h-3.5 rounded focus:ring-1" style="color: var(--color-gold);" data-field="timed" ${card.timed ? 'checked' : ''}>
                <span class="font-light sumi-text">秒数記録</span>
              </label>
              <label class="flex items-center gap-1.5 rounded-lg px-3 py-1.5 border cursor-pointer transition" style="border-color: rgba(115, 115, 115, 0.15); background-color: rgba(245, 237, 214, 0.1);">
                <input type="checkbox" class="w-3.5 h-3.5 rounded focus:ring-1" style="color: var(--color-gold);" data-field="oneHand" ${card.oneHand ? 'checked' : ''}>
                <span class="font-light sumi-text">ワンハンド</span>
              </label>
              <label class="flex items-center gap-1.5 rounded-lg px-3 py-1.5 border cursor-pointer transition" style="border-color: rgba(115, 115, 115, 0.15); background-color: rgba(245, 237, 214, 0.1);">
                <input type="checkbox" class="w-3.5 h-3.5 rounded focus:ring-1" style="color: var(--color-gold);" data-field="dropset" ${card.dropset ? 'checked' : ''}>
                <span class="font-light sumi-text">ドロップセット</span>
              </label>
            </div>
          </div>
        `;
        container.appendChild(cardEl);

        const exerciseSelect = cardEl.querySelector('[data-field="exercise"]');
        const selects = [
          { element: cardEl.querySelector('[data-field="gear"]'), field: 'gear', options: sortForDisplay(getAllGear()).map(value => ({ value, label: value })), allowAdd: true, addType: '器具' },
          { element: cardEl.querySelector('[data-field="attachment"]'), field: 'attachment', options: sortForDisplay(getAllAttachments()).map(value => ({ value, label: value })), allowAdd: true, addType: 'アタッチメント' },
          { element: cardEl.querySelector('[data-field="angle"]'), field: 'angle', options: sortForDisplay(getAllAngles()).map(value => ({ value, label: value })), allowAdd: true, addType: '角度' },
          { element: cardEl.querySelector('[data-field="position"]'), field: 'position', options: sortForDisplay(getAllPositions()).map(value => ({ value, label: value })), allowAdd: true, addType: 'ポジション' }
        ];
        updateExerciseOptions(exerciseSelect, card);
        selects.forEach(select => populateSelect(select.element, select.options, card[select.field], select.allowAdd, select.addType));

        // アタッチメントフィールドの文脈依存表示
        const gearSelect = cardEl.querySelector('[data-field="gear"]');
        const attachmentField = cardEl.querySelector('[data-attachment-field]');
        const attachmentHint = cardEl.querySelector('[data-attachment-hint]');
        
        function updateAttachmentHighlight() {
          const gear = gearSelect.value;
          const needsAttachment = gear === 'ケーブル' || gear === 'マシン';
          if (needsAttachment) {
            attachmentField.classList.add('ring-2', 'ring-amber-200', 'bg-amber-50/30');
            attachmentHint.classList.remove('text-slate-400');
            attachmentHint.classList.add('text-amber-600', 'font-medium');
          } else {
            attachmentField.classList.remove('ring-2', 'ring-amber-200', 'bg-amber-50/30');
            attachmentHint.classList.remove('text-amber-600', 'font-medium');
            attachmentHint.classList.add('text-slate-400');
          }
        }
        
        updateAttachmentHighlight();

        cardEl.querySelectorAll('select, input[type="checkbox"]').forEach(field => {
          field.addEventListener('change', event => {
            const target = event.target;
            const fieldName = target.getAttribute('data-field');
            if (!fieldName) return;
            
            // 新規追加処理
            if (target.value === '__ADD_NEW__') {
              let name = null;
              let addFunction = null;
              let typeName = '';
              
              if (fieldName === 'exercise') {
                typeName = '種目';
                showCustomModal(`新しい${typeName}を追加`, `${typeName}名を入力`, (name) => {
                  if (name && name.trim()) {
                    if (addCustomExercise(card.part, name.trim())) {
                      card.exercise = name.trim();
                      updateExerciseOptions(exerciseSelect, card);
                    } else {
                      target.value = card.exercise || '';
                    }
                  } else {
                    target.value = card.exercise || '';
                  }
                });
                return;
              } else if (fieldName === 'gear') {
                typeName = '器具';
                addFunction = addCustomGear;
              } else if (fieldName === 'attachment') {
                typeName = 'アタッチメント';
                addFunction = addCustomAttachment;
              } else if (fieldName === 'angle') {
                typeName = '角度';
                addFunction = addCustomAngle;
              } else if (fieldName === 'position') {
                typeName = 'ポジション';
                addFunction = addCustomPosition;
              }
              
              if (addFunction) {
                showCustomModal(`新しい${typeName}を追加`, `${typeName}名を入力`, (name) => {
                  if (name && name.trim()) {
                  if (addFunction(name.trim())) {
                    card[fieldName] = name.trim();
                    // ドロップダウンを再構築
                    const select = selects.find(s => s.field === fieldName);
                    if (select) {
                      let newOptions;
                      if (fieldName === 'gear') newOptions = sortForDisplay(getAllGear()).map(value => ({ value, label: value }));
                      else if (fieldName === 'attachment') newOptions = sortForDisplay(getAllAttachments()).map(value => ({ value, label: value }));
                      else if (fieldName === 'angle') newOptions = sortForDisplay(getAllAngles()).map(value => ({ value, label: value }));
                      else if (fieldName === 'position') newOptions = sortForDisplay(getAllPositions()).map(value => ({ value, label: value }));
                      populateSelect(target, newOptions, name.trim(), select.allowAdd, select.addType);
                    }
                  } else {
                    target.value = card[fieldName] || '-';
                  }
                } else {
                  target.value = card[fieldName] || '-';
                }
                });
                return;
              }
            }
            
            // 通常の変更処理
            if (fieldName === 'part') {
              card.part = target.value;
              updateExerciseOptions(exerciseSelect, card);
            } else if (fieldName === 'exercise') {
              card.exercise = target.value;
            } else if (fieldName === 'gear') {
              card.gear = target.value;
              updateAttachmentHighlight();
            } else if (fieldName === 'timed' || fieldName === 'oneHand' || fieldName === 'dropset') {
              card[fieldName] = target.checked;
            } else {
              card[fieldName] = target.value;
            }
          });
        });

        if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length > 2 && index === uiState.exerciseForm.cards.length - 1) {
          cardEl.querySelector('[data-remove="true"]').addEventListener('click', () => {
            uiState.exerciseForm.cards.splice(index, 1);
            renderExercise();
          });
        }
      });

      if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length < 3) {
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'w-full text-sm text-indigo-500 font-semibold px-4 py-3 bg-white rounded-2xl border border-dashed border-indigo-200 min-h-[44px]';
        addBtn.textContent = '＋ カード追加';
        addBtn.addEventListener('click', () => {
          const label = ['A', 'B', 'C'][uiState.exerciseForm.cards.length] || 'C';
          uiState.exerciseForm.cards.push(createExerciseCardState(label));
          renderExercise();
        });
        container.appendChild(addBtn);
      }
    }

    function populateSelect(select, options, selected, allowAdd = false, addType = null) {
      select.innerHTML = '';
      options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        if (option.value === selected) opt.selected = true;
        select.appendChild(opt);
      });
      
      // 新規追加オプションを追加
      if (allowAdd && addType) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = '─────────────';
        select.appendChild(separator);
        
        const addNew = document.createElement('option');
        addNew.value = '__ADD_NEW__';
        addNew.textContent = `＋ 新しい${addType}を追加`;
        select.appendChild(addNew);
      }
    }

    function updateExerciseOptions(select, card) {
      // 部位フィルタリングを適用
      let exercises;
      if (uiState.exerciseForm.selectedParts && uiState.exerciseForm.selectedParts.length > 0) {
        // 選択された部位の種目のみを表示
        exercises = [];
        uiState.exerciseForm.selectedParts.forEach(partId => {
          exercises.push(...getAllExercises(partId));
        });
        exercises = sortForDisplay([...new Set(exercises)]); // 重複を削除
      } else {
        // 部位が選択されていない場合は全ての種目を表示
        exercises = sortForDisplay(getAllExercises(card.part));
      }
      
      const actual = card.exercise && exercises.includes(card.exercise) ? card.exercise : exercises[0] || '';
      select.innerHTML = '';
      exercises.forEach(value => {
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = value;
        if (value === actual) opt.selected = true;
        select.appendChild(opt);
      });
      card.exercise = actual;
      
      // 新規追加オプションを追加
      const separator = document.createElement('option');
      separator.disabled = true;
      separator.textContent = '─────────────';
      select.appendChild(separator);
      
      const addNew = document.createElement('option');
      addNew.value = '__ADD_NEW__';
      addNew.textContent = '＋ 新しい種目を追加';
      select.appendChild(addNew);
    }

    function buildItemsFromExerciseForm() {
      const idBase = Date.now();
      if (!uiState.exerciseForm.superset) {
        const card = uiState.exerciseForm.cards[0];
        return [buildItemFromCard(card, `${idBase}`)];
      }
      const groupId = createGroupId();
      return uiState.exerciseForm.cards.map((card, index) => buildItemFromCard(card, `${idBase}-${index}`, groupId));
    }

    function buildItemFromCard(card, keySeed, groupId = null) {
      return {
        id: createId('item'),
        order: state.day.items.length + 1,
        mode: groupId ? 'superset' : 'single',
        groupId,
        part: card.part,
        exercise: card.exercise,
        gear: card.gear,
        attachment: card.attachment,
        angle: card.angle,
        position: card.position,
        timed: card.timed,
        oneHand: card.oneHand,
        dropset: card.dropset,
        sets: []
      };
    }

    function prepareSetEditor(itemId, isNew = false) {
      const target = state.day.items.find(item => item.id === itemId);
      if (!target) return;
      let items = [];
      if (target.mode === 'superset' && target.groupId) {
        items = state.day.items.filter(item => item.groupId === target.groupId).sort((a, b) => a.order - b.order);
      } else {
        items = [target];
      }
      const editorItems = items.map((item, index) => ({
        itemId: item.id,
        label: ['A', 'B', 'C'][index] || 'A',
        timed: item.timed,
        dropset: item.dropset,
        mode: item.mode,
        rows: buildRowsFromSets(item.sets, item.timed)
      }));
      const maxRound = Math.max(-1, ...items.flatMap(item => item.sets.filter(set => set.round != null).map(set => set.round)));
      uiState.setEditor = {
        isSuperset: target.mode === 'superset',
        activeIndex: items.findIndex(item => item.id === itemId) || 0,
        items: editorItems,
        cycleBuffers: editorItems.map(item => createBuffer(item.timed)),
        nextRound: maxRound + 1,
        isNew
      };
    }

    function buildRowsFromSets(sets, timed) {
      const rows = [];
      let current = null;
      sets.sort((a, b) => a.ts - b.ts).forEach(set => {
        if (!set.drop) {
          current = createRowFromSet(set);
          rows.push(current);
        } else if (current) {
          current.drops.push(createDropFromSet(set));
        } else {
          const orphan = createRowFromSet(set);
          rows.push(orphan);
        }
      });
      if (rows.length === 0) {
        rows.push(createBlankRow(timed));
      }
      return rows;
    }

    function createRowFromSet(set) {
      return {
        id: set.id || createId('row'),
        weight: set.weight ?? '',
        repsU: set.repsU ?? '',
        repsA: set.repsA ?? '',
        seconds: set.seconds ?? '',
        warmup: !!set.warmup,
        round: set.round ?? null,
        drops: []
      };
    }

    function createDropFromSet(set) {
      return {
        id: set.id || createId('drop'),
        weight: set.weight ?? '',
        repsU: set.repsU ?? '',
        repsA: set.repsA ?? '',
        seconds: set.seconds ?? '',
        warmup: !!set.warmup,
        round: set.round ?? null
      };
    }

    function createBlankRow(timed, round = null) {
      return {
        id: createId('row'),
        weight: timed ? '' : '',
        repsU: '',
        repsA: '',
        seconds: timed ? '' : '',
        warmup: false,
        round,
        drops: [],
        memo: ''
      };
    }

    function createBlankDrop(timed, round = null) {
      return {
        id: createId('drop'),
        weight: timed ? '' : '',
        repsU: '',
        repsA: '',
        seconds: timed ? '' : '',
        warmup: false,
        round
      };
    }

    function createBuffer(timed) {
      return {
        row: createBlankRow(timed),
        drops: []
      };
    }
    
    // RM計算関数
    function calculateEstimated1RM(weight, reps) {
      if (!weight || !reps || reps === 0) return null;
      // Epley式: 1RM = 重量 × (1 + 回数 / 30)
      return Math.round(weight * (1 + reps / 30) * 10) / 10;
    }
    
    // 過去の最高記録を取得
    function getPersonalRecords(exercise, gear, attachment, angle, position) {
      const matchingWorkouts = state.history.filter(workout => {
        return workout.items.some(item => 
          item.exercise === exercise &&
          item.gear === gear &&
          item.attachment === attachment &&
          item.angle === angle &&
          item.position === position
        );
      });
      
      let maxWeight = 0;
      let maxEstimated1RM = 0;
      let bestSet = null;
      
      matchingWorkouts.forEach(workout => {
        workout.items.forEach(item => {
          if (item.exercise === exercise &&
              item.gear === gear &&
              item.attachment === attachment &&
              item.angle === angle &&
              item.position === position) {
            item.sets.forEach(set => {
              if (set.warmup) return; // ウォームアップは除外
              const totalReps = (set.repsU || 0) + (set.repsA || 0);
              if (set.weight && set.weight > maxWeight) {
                maxWeight = set.weight;
              }
              const estimated1RM = calculateEstimated1RM(set.weight, totalReps);
              if (estimated1RM && estimated1RM > maxEstimated1RM) {
                maxEstimated1RM = estimated1RM;
                bestSet = { weight: set.weight, reps: totalReps, date: workout.date };
              }
            });
          }
        });
      });
      
      return {
        maxWeight,
        maxEstimated1RM,
        bestSet
      };
    }

    function renderSet() {
      const container = document.querySelector('[data-route="#/set"]');
      container.innerHTML = '';
      const editor = uiState.setEditor;
      if (!editor) {
        const message = document.createElement('p');
        message.className = 'text-sm text-slate-500';
        message.textContent = '編集対象の種目が選択されていません。';
        container.appendChild(message);
        return;
      }
      const section = document.createElement('section');
      section.className = 'section-card bg-white p-4 space-y-4';

      // スーパーセット時はラウンド（セット）単位で表示
      if (editor.isSuperset) {
        renderSupersetByRound(editor, section);
      } else {
        // 単独種目の場合
        const active = editor.items[editor.activeIndex];
        activeEditSession = active; // 自動保存用にグローバル変数に設定
        const item = state.day.items.find(it => it.id === active.itemId);
        if (!item) {
          container.appendChild(section);
          return;
        }

        const subtitle = [item.gear, item.attachment, item.angle, item.position]
          .map(value => (value && value !== '-') ? value : '―')
          .join(' / ');
        const header = document.createElement('div');
        header.className = 'flex items-start justify-between gap-3 mb-2';
        const headerLeft = document.createElement('div');
        headerLeft.innerHTML = `
          <h2 class="text-lg font-light sumi-text" style="letter-spacing: 0.03em;">${item.exercise}</h2>
          <p class="text-[10px] sumi-text-light font-light mt-0.5">${subtitle}</p>
        `;
        header.appendChild(headerLeft);
        
        const editExerciseBtn = document.createElement('button');
        editExerciseBtn.type = 'button';
        editExerciseBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
        editExerciseBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
        editExerciseBtn.textContent = '種目を編集';
        editExerciseBtn.addEventListener('click', () => {
          // 現在の種目情報をformStateに設定
          uiState.formState = {
            part: item.part,
            exercise: item.exercise,
            gear: item.gear,
            attachment: item.attachment,
            angle: item.angle,
            position: item.position,
            timed: item.timed,
            oneHand: item.oneHand
          };
          navigate('#/exercise');
        });
        header.appendChild(editExerciseBtn);
        section.appendChild(header);
        
        // 過去の最高記録を表示
        const records = getPersonalRecords(item.exercise, item.gear, item.attachment, item.angle, item.position);
        if (records.bestSet) {
          const recordInfo = document.createElement('div');
          recordInfo.className = 'text-xs sumi-text-light font-light py-2 px-3 rounded-lg';
          recordInfo.style.cssText = 'background-color: rgba(245, 237, 214, 0.15); border-left: 3px solid var(--color-gold);';
          const date = new Date(records.bestSet.date);
          const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
          recordInfo.innerHTML = `
            <span style="color: var(--color-gold);">📊</span> 
            <strong>最高記録:</strong> ${records.bestSet.weight}kg×${records.bestSet.reps} 
            <span class="sumi-text-light">(推定1RM: ${records.maxEstimated1RM}kg)</span>
            <span class="sumi-text-light ml-2">${dateStr}</span>
          `;
          section.appendChild(recordInfo);
        }

        const rowsWrapper = document.createElement('div');
        rowsWrapper.className = 'space-y-2.5';
        renderRows(active, rowsWrapper);
        section.appendChild(rowsWrapper);
      }

      // 共通のフッター
      const footer = createSetFooter(editor);
      section.appendChild(footer);
      container.appendChild(section);
    }

    function renderSupersetByRound(editor, section) {
      // 最大ラウンド数を取得
      const maxRounds = Math.max(...editor.items.map(item => {
        const rounds = new Set(item.rows.filter(r => r.round != null).map(r => r.round));
        return rounds.size > 0 ? Math.max(...rounds) : 0;
      }));

      // ラウンドごとに表示
      for (let round = 0; round <= maxRounds; round++) {
        const roundCard = document.createElement('div');
        roundCard.className = 'border rounded-xl p-3 space-y-3';
        roundCard.style.borderColor = 'rgba(212, 175, 55, 0.25)';
        roundCard.style.backgroundColor = 'rgba(245, 237, 214, 0.05)';

        // 各種目のこのラウンドのセットを表示
        editor.items.forEach((activeItem, itemIndex) => {
          const item = state.day.items.find(it => it.id === activeItem.itemId);
          if (!item) return;

          const rowsForRound = activeItem.rows.filter(r => r.round === round);
          if (rowsForRound.length === 0) return;

          const subtitle = [item.gear, item.attachment, item.angle, item.position]
            .map(value => (value && value !== '-') ? value : '―')
            .join(' / ');

          const exerciseBlock = document.createElement('div');
          exerciseBlock.className = 'space-y-2';

          const header = document.createElement('div');
          header.innerHTML = `
            <div class="flex items-center gap-2">
              <span class="text-xs font-light px-1.5 py-0.5 rounded" style="background-color: var(--color-gold); color: white;">${activeItem.label}</span>
              <h4 class="text-sm font-light sumi-text" style="letter-spacing: 0.02em;">${item.exercise}</h4>
            </div>
            <p class="text-[10px] sumi-text-light font-light mt-0.5">${subtitle}</p>
          `;
          exerciseBlock.appendChild(header);

          // このラウンドのセットを表示
          rowsForRound.forEach((row, rowIndex) => {
            const actualRowIndex = activeItem.rows.indexOf(row);
            const rowCard = createSetInputCard(row, actualRowIndex, activeItem, item.timed, item.dropset);
            exerciseBlock.appendChild(rowCard);
          });

          roundCard.appendChild(exerciseBlock);
        });

        section.appendChild(roundCard);
      }

      // セット追加ボタン
      const addRoundBtn = document.createElement('button');
      addRoundBtn.type = 'button';
      addRoundBtn.className = 'w-full text-xs font-light px-3 py-2 bg-white rounded-lg min-h-[32px] border transition';
      addRoundBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
      addRoundBtn.style.color = 'var(--color-gold)';
      addRoundBtn.textContent = '＋ ラウンド追加';
      addRoundBtn.addEventListener('click', () => {
        const nextRound = maxRounds + 1;
        editor.items.forEach(activeItem => {
          // 直前のラウンドを取得
          const lastRow = activeItem.rows[activeItem.rows.length - 1];
          
          activeItem.rows.push({
            round: nextRound,
            weight: lastRow && !activeItem.timed ? (lastRow.weight || null) : null,
            repsU: lastRow && !activeItem.timed ? (lastRow.repsU || null) : null,
            repsA: lastRow && !activeItem.timed ? (lastRow.repsA || 0) : 0,
            seconds: lastRow && activeItem.timed ? (lastRow.seconds || null) : null,
            warmup: false,
            drops: []
          });
        });
        renderSet();
      });
      section.appendChild(addRoundBtn);
    }

    function createSetInputCard(row, rowIndex, activeItem, isTimed, isDropsetEnabled) {
      const rowCard = document.createElement('div');
      rowCard.className = 'bg-white rounded-xl p-2.5 space-y-2 border border-neutral-200/40 shadow-sm';

      // 1行に統合: ウォームアップ + 入力欄 + 削除ボタン
      const mainRow = document.createElement('div');
      mainRow.className = 'flex items-center gap-2 text-sm sumi-text';
      
      // ウォームアップチェックボックス（左端）
      const warmupLabel = document.createElement('label');
      warmupLabel.className = 'inline-flex items-center gap-1 text-xs sumi-text-light cursor-pointer flex-shrink-0';
      const warmupInput = document.createElement('input');
      warmupInput.type = 'checkbox';
      warmupInput.className = 'w-4 h-4 rounded';
      warmupInput.style.accentColor = 'var(--color-gold)';
      warmupInput.checked = row.warmup;
      warmupInput.addEventListener('change', () => { row.warmup = warmupInput.checked; autoSaveDraft(); });
      warmupLabel.append(warmupInput, document.createTextNode('W'));
      mainRow.appendChild(warmupLabel);
      
      // 入力欄（中央）
      const inputsWrapper = document.createElement('div');
      inputsWrapper.className = 'flex gap-2 flex-1';
      if (isTimed) {
        inputsWrapper.appendChild(createCompactNumberInput('秒数', row.seconds, value => { row.seconds = value; }));
      } else {
        inputsWrapper.appendChild(createCompactNumberInput('重量', row.weight, value => { row.weight = value; }));
        inputsWrapper.appendChild(createCompactNumberInput('自力', row.repsU, value => { row.repsU = value; }));
        inputsWrapper.appendChild(createCompactNumberInput('補助', row.repsA, value => { row.repsA = value; }, 0));
      }
      mainRow.appendChild(inputsWrapper);
      
      // 削除ボタン（右端、×アイコン）
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full transition';
      removeBtn.style.cssText = 'color: var(--color-sumi-light); background-color: rgba(115, 115, 115, 0.05);';
      removeBtn.innerHTML = '×';
      removeBtn.style.fontSize = '20px';
      removeBtn.addEventListener('click', () => {
        activeItem.rows.splice(rowIndex, 1);
        renderSet();
      });
      removeBtn.addEventListener('mouseenter', () => {
        removeBtn.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
        removeBtn.style.color = '#ef4444';
      });
      removeBtn.addEventListener('mouseleave', () => {
        removeBtn.style.backgroundColor = 'rgba(115, 115, 115, 0.05)';
        removeBtn.style.color = 'var(--color-sumi-light)';
      });
      mainRow.appendChild(removeBtn);
      
      rowCard.appendChild(mainRow);

      // セットメモ入力欄（ウォームアップの下）
      const memoInput = document.createElement('input');
      memoInput.type = 'text';
      memoInput.className = 'w-full px-2 py-1 text-xs rounded-lg border transition';
      memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
      memoInput.style.backgroundColor = 'rgba(245, 237, 214, 0.05)';
      memoInput.placeholder = 'セットメモ...';
      memoInput.value = row.memo || '';
      memoInput.addEventListener('input', () => { row.memo = memoInput.value; autoSaveDraft(); });
      memoInput.addEventListener('focus', () => {
        memoInput.style.outline = 'none';
        memoInput.style.borderColor = 'var(--color-gold)';
        memoInput.style.boxShadow = '0 0 0 3px rgba(212, 175, 55, 0.1)';
      });
      memoInput.addEventListener('blur', () => {
        memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
        memoInput.style.boxShadow = 'none';
      });
      rowCard.appendChild(memoInput);

      // ドロップセットエリア（後で削除予定）
      const dropArea = document.createElement('div');
      dropArea.className = 'space-y-2.5';
      row.drops.forEach((drop, dropIndex) => {
        const dropCard = document.createElement('div');
        dropCard.className = 'rounded-lg p-2.5 space-y-2 border border-dashed';
        dropCard.style.borderColor = 'rgba(212, 175, 55, 0.3)';
        dropCard.style.backgroundColor = 'rgba(245, 237, 214, 0.15)';
        const dropTitle = document.createElement('p');
        dropTitle.className = 'text-[10px] font-light';
        dropTitle.style.color = 'var(--color-gold)';
        dropTitle.textContent = 'ドロップセット';
        dropCard.appendChild(dropTitle);
        const dropGrid = document.createElement('div');
        dropGrid.className = 'flex gap-2 text-sm sumi-text';
        if (isTimed) {
          dropGrid.appendChild(createCompactNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
        } else {
          dropGrid.appendChild(createCompactNumberInput('重量', drop.weight, value => { drop.weight = value; }));
          dropGrid.appendChild(createCompactNumberInput('自力', drop.repsU, value => { drop.repsU = value; }));
          dropGrid.appendChild(createCompactNumberInput('補助', drop.repsA, value => { drop.repsA = value; }, 0));
        }
        dropCard.appendChild(dropGrid);
        const dropToggle = document.createElement('label');
        dropToggle.className = 'inline-flex items-center gap-1 text-[10px] sumi-text-light cursor-pointer';
        const dropWarm = document.createElement('input');
        dropWarm.type = 'checkbox';
        dropWarm.className = 'w-3 h-3 rounded';
        dropWarm.style.accentColor = 'var(--color-gold)';
        dropWarm.checked = drop.warmup;
        dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; autoSaveDraft(); });
        dropToggle.append(dropWarm, document.createTextNode('W'));
        dropCard.appendChild(dropToggle);
        const dropFooter = document.createElement('div');
        dropFooter.className = 'flex justify-end';
        const dropRemove = document.createElement('button');
        dropRemove.type = 'button';
        dropRemove.className = 'text-[10px] font-light px-2 py-0.5 transition';
        dropRemove.style.color = 'var(--color-sumi-light)';
        dropRemove.textContent = '削除';
        dropRemove.addEventListener('click', () => {
          row.drops.splice(dropIndex, 1);
          renderSet();
        });
        dropFooter.appendChild(dropRemove);
        dropCard.appendChild(dropFooter);
        dropArea.appendChild(dropCard);
      });
      if (row.drops.length > 0) {
        rowCard.appendChild(dropArea);
      }

      // ドロップセットが有効な場合のみボタンを表示
      if (isDropsetEnabled) {
        const addDropBtn = document.createElement('button');
        addDropBtn.type = 'button';
        addDropBtn.className = 'w-full text-[10px] font-light px-2 py-1.5 rounded-lg border transition';
        addDropBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
        addDropBtn.style.color = 'var(--color-gold)';
        addDropBtn.textContent = '＋ ドロップセット';
        addDropBtn.addEventListener('click', () => {
          row.drops.push({
            weight: null,
            repsU: null,
            repsA: 0,
            seconds: null,
            warmup: false
          });
          renderSet();
        });
        rowCard.appendChild(addDropBtn);
      }

      return rowCard;
    }

    function renderRows(active, rowsWrapper) {
      // 現在の種目の最高記録を取得
      const item = state.day.items.find(it => it.id === active.itemId);
      const records = item ? getPersonalRecords(item.exercise, item.gear, item.attachment, item.angle, item.position) : { maxEstimated1RM: 0 };
      
      active.rows.forEach((row, rowIndex) => {
        const rowCard = document.createElement('div');
        rowCard.className = 'bg-white rounded-xl p-2.5 space-y-2 border border-neutral-200/40 shadow-sm';
        if (row.round != null) {
          const title = document.createElement('div');
          title.className = 'flex items-center justify-between text-xs sumi-text-mid font-light';
          title.textContent = `ラウンド ${row.round}`;
          rowCard.appendChild(title);
        }

        // 記録更新チェック関数（ウォームアップチェックボックスからもアクセスできるように外側で定義）
        const checkNewRecord = () => {
          if (active.timed) return; // 時間制は除外
          if (row.warmup) {
            // ウォームアップの場合は通常の背景色に戻す
            rowCard.style.backgroundColor = '';
            rowCard.style.borderColor = '';
            const badge = rowCard.querySelector('.new-record-badge');
            if (badge) badge.remove();
            return;
          }
          
          const totalReps = (row.repsU || 0) + (row.repsA || 0);
          const currentEstimated1RM = calculateEstimated1RM(row.weight, totalReps);
          
          if (currentEstimated1RM && currentEstimated1RM > records.maxEstimated1RM) {
            // 新記録！
            rowCard.style.backgroundColor = 'rgba(34, 197, 94, 0.08)';
            rowCard.style.borderColor = 'rgba(34, 197, 94, 0.3)';
            
            // 新記録バッジがなければ追加
            if (!rowCard.querySelector('.new-record-badge')) {
              const badge = document.createElement('div');
              badge.className = 'new-record-badge text-xs font-light px-2 py-0.5 rounded-full inline-block';
              badge.style.cssText = 'background-color: rgba(34, 197, 94, 0.15); color: rgb(34, 197, 94);';
              badge.textContent = '🎉 新記録！';
              rowCard.insertBefore(badge, rowCard.firstChild);
            }
          } else {
            // 通常の背景色に戻す
            rowCard.style.backgroundColor = '';
            rowCard.style.borderColor = '';
            
            // バッジを削除
            const badge = rowCard.querySelector('.new-record-badge');
            if (badge) badge.remove();
          }
        };

        const grid = document.createElement('div');
        grid.className = 'flex gap-2 text-sm sumi-text';
        if (active.timed) {
          grid.appendChild(createCompactNumberInput('秒数', row.seconds, value => { row.seconds = value; }));
        } else {
          const weightInput = createCompactNumberInput('重量', row.weight, value => { 
            row.weight = value;
            checkNewRecord();
          });
          const repsUInput = createCompactNumberInput('自力', row.repsU, value => { 
            row.repsU = value;
            checkNewRecord();
          });
          const repsAInput = createCompactNumberInput('補助', row.repsA, value => { 
            row.repsA = value;
            checkNewRecord();
          }, 0);
          grid.appendChild(weightInput);
          grid.appendChild(repsUInput);
          grid.appendChild(repsAInput);
          
          // 初期チェック
          checkNewRecord();
        }
        rowCard.appendChild(grid);

        const toggles = document.createElement('div');
        toggles.className = 'flex items-center justify-between gap-2 text-sm sumi-text';
        const warmupLabel = document.createElement('label');
        warmupLabel.className = 'inline-flex items-center gap-1 text-xs sumi-text-light cursor-pointer';
        const warmupInput = document.createElement('input');
        warmupInput.type = 'checkbox';
        warmupInput.className = 'w-3 h-3 rounded';
        warmupInput.style.accentColor = 'var(--color-gold)';
        warmupInput.checked = row.warmup;
        warmupInput.addEventListener('change', () => { 
          row.warmup = warmupInput.checked;
          checkNewRecord();
        });
        warmupLabel.append(warmupInput, document.createTextNode('W'));
        toggles.appendChild(warmupLabel);
        
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'text-xs font-light px-3 py-1 transition';
        removeBtn.style.color = 'var(--color-sumi-light)';
        removeBtn.textContent = 'このセットを削除';
        removeBtn.addEventListener('click', () => {
          active.rows.splice(rowIndex, 1);
          if (active.rows.length === 0) {
            active.rows.push(createBlankRow(active.timed));
          }
          renderSet();
        });
        toggles.appendChild(removeBtn);
        rowCard.appendChild(toggles);

        // セットメモ入力欄（ウォームアップの下）
        const memoInput = document.createElement('input');
        memoInput.type = 'text';
        memoInput.className = 'w-full px-2 py-1 text-xs rounded-lg border transition';
        memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
        memoInput.style.backgroundColor = 'rgba(245, 237, 214, 0.05)';
        memoInput.placeholder = 'セットメモ...';
        memoInput.value = row.memo || '';
        memoInput.addEventListener('input', () => { row.memo = memoInput.value; autoSaveDraft(); });
        memoInput.addEventListener('focus', () => {
          memoInput.style.outline = 'none';
          memoInput.style.borderColor = 'var(--color-gold)';
          memoInput.style.boxShadow = '0 0 0 3px rgba(212, 175, 55, 0.1)';
        });
        memoInput.addEventListener('blur', () => {
          memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
          memoInput.style.boxShadow = 'none';
        });
        rowCard.appendChild(memoInput);

        const dropArea = document.createElement('div');
        dropArea.className = 'space-y-2.5';
        row.drops.forEach((drop, dropIndex) => {
          const dropCard = document.createElement('div');
          dropCard.className = 'rounded-lg p-2.5 space-y-2 border border-dashed';
          dropCard.style.borderColor = 'rgba(212, 175, 55, 0.3)';
          dropCard.style.backgroundColor = 'rgba(245, 237, 214, 0.15)';
          const dropTitle = document.createElement('p');
          dropTitle.className = 'text-[10px] font-light';
          dropTitle.style.color = 'var(--color-gold)';
          dropTitle.textContent = 'ドロップセット';
          dropCard.appendChild(dropTitle);
          const dropGrid = document.createElement('div');
          dropGrid.className = 'flex gap-2 text-sm sumi-text';
          if (active.timed) {
            dropGrid.appendChild(createCompactNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
          } else {
            dropGrid.appendChild(createCompactNumberInput('重量', drop.weight, value => { drop.weight = value; }));
            dropGrid.appendChild(createCompactNumberInput('自力', drop.repsU, value => { drop.repsU = value; }));
            dropGrid.appendChild(createCompactNumberInput('補助', drop.repsA, value => { drop.repsA = value; }, 0));
          }
          dropCard.appendChild(dropGrid);
          const dropToggle = document.createElement('label');
          dropToggle.className = 'inline-flex items-center gap-1 text-[10px] sumi-text-light cursor-pointer';
          const dropWarm = document.createElement('input');
          dropWarm.type = 'checkbox';
          dropWarm.className = 'w-3 h-3 rounded';
          dropWarm.style.accentColor = 'var(--color-gold)';
          dropWarm.checked = drop.warmup;
          dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; autoSaveDraft(); });
          dropToggle.append(dropWarm, document.createTextNode('W'));
          dropCard.appendChild(dropToggle);
          const dropFooter = document.createElement('div');
          dropFooter.className = 'flex justify-end';
          const dropRemove = document.createElement('button');
          dropRemove.type = 'button';
          dropRemove.className = 'text-[10px] font-light px-2 py-0.5 transition';
          dropRemove.style.color = 'var(--color-sumi-light)';
          dropRemove.textContent = '削除';
          dropRemove.addEventListener('click', () => {
            row.drops.splice(dropIndex, 1);
            renderSet();
          });
          dropFooter.appendChild(dropRemove);
          dropCard.appendChild(dropFooter);
          dropArea.appendChild(dropCard);
        });
        // ドロップセットが有効な場合のみボタンを表示
        if (active.dropset) {
          const addDropBtn = document.createElement('button');
          addDropBtn.type = 'button';
          addDropBtn.className = 'w-full text-xs font-light px-4 py-2 bg-white rounded-xl min-h-[36px] border transition';
          addDropBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
          addDropBtn.style.color = 'var(--color-gold)';
          addDropBtn.textContent = '＋ ドロップセット';
          addDropBtn.addEventListener('click', () => {
            row.drops.push(createBlankDrop(active.timed, row.round));
            renderSet();
          });
          dropArea.appendChild(addDropBtn);
        }
        rowCard.appendChild(dropArea);

        rowsWrapper.appendChild(rowCard);
      });
      
      const addSetBtn = document.createElement('button');
      addSetBtn.type = 'button';
      addSetBtn.className = 'w-full text-xs font-light px-3 py-2 bg-white rounded-lg min-h-[32px] border transition';
      addSetBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
      addSetBtn.style.color = 'var(--color-gold)';
      addSetBtn.textContent = '＋ セット追加';
      addSetBtn.addEventListener('click', () => {
        // 直前のセットを取得
        const lastRow = active.rows[active.rows.length - 1];
        
        // 直前のセットの内容を引き継ぐ
        const newRow = createBlankRow(active.timed);
        if (lastRow && !active.timed) {
          newRow.weight = lastRow.weight || null;
          newRow.repsU = lastRow.repsU || null;
          newRow.repsA = lastRow.repsA || null;
          // ウォームアップとメモはリセット
          newRow.warmup = false;
          newRow.memo = '';
        }
        
        active.rows.push(newRow);
        renderSet();
      });
      rowsWrapper.appendChild(addSetBtn);
    }

    function createSetFooter(editor) {
      const footer = document.createElement('div');
      footer.className = 'flex flex-col sm:flex-row gap-2.5 justify-between pt-2';
      const saveBack = document.createElement('button');
      saveBack.type = 'button';
      saveBack.className = 'ios-card text-white px-6 py-3 font-light min-h-[44px] transition';
      saveBack.style.backgroundColor = 'var(--color-gold)';
      saveBack.style.letterSpacing = '0.05em';
      saveBack.textContent = '保存して戻る';
      saveBack.addEventListener('click', () => {
        persistSetEditor();
        navigate('#/today');
      });
      const saveNext = document.createElement('button');
      saveNext.type = 'button';
      saveNext.className = 'ios-card bg-white px-6 py-3 font-light min-h-[44px] border transition';
      saveNext.style.borderColor = 'rgba(212, 175, 55, 0.3)';
      saveNext.style.color = 'var(--color-gold)';
      saveNext.textContent = '次の種目へ';
      saveNext.addEventListener('click', () => {
        persistSetEditor();
        uiState.exerciseForm = createExerciseFormState();
        navigate('#/exercise');
      });
      footer.append(saveBack, saveNext);
      return footer;
    }

    function renderRoundBuffer(editor) {
      const wrapper = document.createElement('div');
      wrapper.className = 'space-y-4 bg-indigo-50 rounded-2xl p-4 border border-indigo-200';
      const title = document.createElement('div');
      title.className = 'flex items-center justify-between';
      title.innerHTML = `
        <div>
          <p class="text-sm font-semibold text-indigo-700">ラウンド入力</p>
          <p class="text-xs text-indigo-500">現在のラウンド番号: ${editor.nextRound}</p>
        </div>
        <button type="button" class="ios-card bg-indigo-500 text-white px-4 py-2 text-sm font-semibold min-h-[40px]" id="nextRoundBtn">次ラウンドへ</button>
      `;
      wrapper.appendChild(title);
      const activeBuffer = editor.cycleBuffers[editor.activeIndex];
      const activeItem = editor.items[editor.activeIndex];
      const grid = document.createElement('div');
      grid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-indigo-700';
      if (activeItem.timed) {
        grid.appendChild(createNumberInput('秒数', activeBuffer.row.seconds, value => { activeBuffer.row.seconds = value; }));
      } else {
        grid.appendChild(createNumberInput('重量(kg)', activeBuffer.row.weight, value => { activeBuffer.row.weight = value; }));
        grid.appendChild(createNumberInput('自力レップ', activeBuffer.row.repsU, value => { activeBuffer.row.repsU = value; }));
        grid.appendChild(createNumberInput('補助レップ', activeBuffer.row.repsA, value => { activeBuffer.row.repsA = value; }, 0));
      }
      wrapper.appendChild(grid);
      const warmupRow = document.createElement('label');
      warmupRow.className = 'inline-flex items-center gap-1 text-xs sumi-text-light min-h-[32px]';
      const warmupInput = document.createElement('input');
      warmupInput.type = 'checkbox';
      warmupInput.className = 'w-3 h-3 rounded';
      warmupInput.style.accentColor = 'var(--color-gold)';
      warmupInput.checked = activeBuffer.row.warmup;
      warmupInput.addEventListener('change', () => { activeBuffer.row.warmup = warmupInput.checked; autoSaveDraft(); });
      warmupRow.append(warmupInput, document.createTextNode('W'));
      wrapper.appendChild(warmupRow);

      activeBuffer.drops.forEach((drop, index) => {
        const dropCard = document.createElement('div');
        dropCard.className = 'bg-white rounded-2xl p-4 space-y-3 border border-dashed border-indigo-200';
        const dropTitle = document.createElement('p');
        dropTitle.className = 'text-xs font-semibold text-indigo-600';
        dropTitle.textContent = 'ドロップセット';
        dropCard.appendChild(dropTitle);
        const dropGrid = document.createElement('div');
        dropGrid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-indigo-700';
        if (activeItem.timed) {
          dropGrid.appendChild(createNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
        } else {
          dropGrid.appendChild(createNumberInput('重量(kg)', drop.weight, value => { drop.weight = value; }));
          dropGrid.appendChild(createNumberInput('自力レップ', drop.repsU, value => { drop.repsU = value; }));
          dropGrid.appendChild(createNumberInput('補助レップ', drop.repsA, value => { drop.repsA = value; }, 0));
        }
        dropCard.appendChild(dropGrid);
        const dropToggle = document.createElement('label');
        dropToggle.className = 'inline-flex items-center gap-1 text-xs sumi-text-light min-h-[32px]';
        const dropWarm = document.createElement('input');
        dropWarm.type = 'checkbox';
        dropWarm.className = 'w-3 h-3 rounded';
        dropWarm.style.accentColor = 'var(--color-gold)';
        dropWarm.checked = drop.warmup;
        dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; autoSaveDraft(); });
        dropToggle.append(dropWarm, document.createTextNode('W'));
        dropCard.appendChild(dropToggle);
        const dropFooter = document.createElement('div');
        dropFooter.className = 'flex justify-end';
        const dropRemove = document.createElement('button');
        dropRemove.type = 'button';
        dropRemove.className = 'text-xs text-rose-500 font-semibold px-3 py-1 min-h-[32px]';
        dropRemove.textContent = '削除';
        dropRemove.addEventListener('click', () => {
          activeBuffer.drops.splice(index, 1);
          renderSet();
        });
        dropFooter.appendChild(dropRemove);
        dropCard.appendChild(dropFooter);
        wrapper.appendChild(dropCard);
      });

      const addDropBtn = document.createElement('button');
      addDropBtn.type = 'button';
      addDropBtn.className = 'w-full text-xs text-indigo-500 font-semibold px-4 py-2 bg-white rounded-2xl min-h-[40px]';
      addDropBtn.textContent = '＋ ドロップセット';
      addDropBtn.addEventListener('click', () => {
        activeBuffer.drops.push(createBlankDrop(activeItem.timed));
        renderSet();
      });
      wrapper.appendChild(addDropBtn);

      wrapper.querySelector('#nextRoundBtn').addEventListener('click', () => {
        advanceRoundCycle();
      });

      return wrapper;
    }

    function createCompactNumberInput(labelText, value, onInput, min = 0) {
      const wrapper = document.createElement('label');
      wrapper.className = 'flex-1 flex flex-col gap-1';
      const label = document.createElement('span');
      label.className = 'text-[10px] sumi-text-mid font-light';
      label.textContent = labelText;
      wrapper.appendChild(label);
      const input = document.createElement('input');
      input.type = 'number';
      input.inputMode = 'numeric';
      input.min = String(min);
      input.value = value ?? '';
      input.className = 'rounded-lg border px-2 py-1.5 text-sm sumi-text font-light transition focus:outline-none focus:ring-1 w-full';
      input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
      input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      input.addEventListener('focus', () => {
        input.style.borderColor = 'var(--color-gold)';
        input.style.backgroundColor = 'rgba(245, 237, 214, 0.1)';
      });
      input.addEventListener('blur', () => {
        input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
        input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      });
      input.addEventListener('input', () => {
        const numValue = input.value === '' ? null : Number(input.value);
        onInput(numValue);
        autoSaveDraft(); // 自動保存
      });
      wrapper.appendChild(input);
      return wrapper;
    }

    function createNumberInput(labelText, value, onInput, min = 0) {
      const wrapper = document.createElement('label');
      wrapper.className = 'flex flex-col gap-1.5';
      const label = document.createElement('span');
      label.className = 'text-xs sumi-text-mid font-light';
      label.textContent = labelText;
      wrapper.appendChild(label);
      const input = document.createElement('input');
      input.type = 'number';
      input.inputMode = 'numeric';
      input.min = String(min);
      input.value = value ?? '';
      input.className = 'rounded-lg border px-3 py-2 text-sm sumi-text font-light transition focus:outline-none focus:ring-1';
      input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
      input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      input.addEventListener('focus', () => {
        input.style.borderColor = 'var(--color-gold)';
        input.style.backgroundColor = 'rgba(245, 237, 214, 0.1)';
      });
      input.addEventListener('blur', () => {
        input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
        input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      });
      input.addEventListener('input', () => {
        const numValue = input.value === '' ? null : Number(input.value);
        onInput(numValue);
        autoSaveDraft(); // 自動保存
      });
      wrapper.appendChild(input);
      return wrapper;
    }

    function bufferHasData(buffer, timed) {
      if (timed) {
        return buffer.row.seconds !== '' || buffer.drops.some(drop => drop.seconds !== '');
      }
      const baseFilled = buffer.row.weight !== '' || buffer.row.repsU !== '' || buffer.row.repsA !== '';
      const dropFilled = buffer.drops.some(drop => drop.weight !== '' || drop.repsU !== '' || drop.repsA !== '');
      return baseFilled || dropFilled;
    }

    function advanceRoundCycle() {
      const editor = uiState.setEditor;
      if (!editor || !editor.isSuperset) return;
      const buffer = editor.cycleBuffers[editor.activeIndex];
      editor.activeIndex = (editor.activeIndex + 1) % editor.items.length;
      if (editor.activeIndex === 0) {
        finalizeRoundBuffer();
      } else {
        renderSet();
      }
    }

    function finalizeRoundBuffer() {
      const editor = uiState.setEditor;
      if (!editor) return;
      const entries = editor.cycleBuffers.map((buffer, index) => {
        const item = editor.items[index];
        if (!bufferHasData(buffer, item.timed)) return null;
        const row = createBlankRow(item.timed, editor.nextRound);
        row.weight = buffer.row.weight;
        row.repsU = buffer.row.repsU;
        row.repsA = buffer.row.repsA;
        row.seconds = buffer.row.seconds;
        row.warmup = buffer.row.warmup;
        row.drops = buffer.drops.map(drop => ({
          id: createId('drop'),
          weight: drop.weight,
          repsU: drop.repsU,
          repsA: drop.repsA,
          seconds: drop.seconds,
          warmup: drop.warmup,
          round: editor.nextRound
        }));
        return row;
      });
      const hasAny = entries.some(entry => entry !== null);
      if (hasAny) {
        entries.forEach((row, index) => {
          if (!row) return;
          editor.items[index].rows.push(row);
        });
        editor.nextRound += 1;
      }
      editor.cycleBuffers = editor.items.map(item => createBuffer(item.timed));
      renderSet();
    }

    function persistSetEditor() {
      const editor = uiState.setEditor;
      if (!editor) return;
      editor.items.forEach(itemState => {
        const item = state.day.items.find(it => it.id === itemState.itemId);
        if (!item) return;
        const newSets = [];
        itemState.rows.forEach(row => {
          const built = buildSetsFromRow(row, itemState.timed);
          built.forEach(set => newSets.push(set));
        });
        item.sets = newSets;
      });
      state.day.items.sort((a, b) => a.order - b.order).forEach((entry, index) => {
        entry.order = index + 1;
      });
      renderToday();
    }

    function buildSetsFromRow(row, timed) {
      const sets = [];
      const base = convertRowToSet(row, timed, false);
      if (base) sets.push(base);
      row.drops.forEach(drop => {
        const dropSet = convertRowToSet({ ...drop, round: drop.round ?? row.round }, timed, true);
        if (dropSet) sets.push(dropSet);
      });
      return sets;
    }

    function convertRowToSet(row, timed, isDrop) {
      if (timed) {
        const seconds = parseNumber(row.seconds);
        if (seconds == null) return null;
        return createSet({ seconds, warmup: !!row.warmup, drop: isDrop, round: row.round ?? null });
      }
      const weight = parseNumber(row.weight);
      const repsU = parseNumber(row.repsU);
      const repsA = parseNumber(row.repsA);
      if (weight == null && repsU == null && repsA == null) return null;
      return createSet({ weight, repsU, repsA, warmup: !!row.warmup, drop: isDrop, round: row.round ?? null });
    }

    function parseNumber(value) {
      if (value === '' || value === null || value === undefined) return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    }

    function renderHistory() {
      const container = document.querySelector('[data-route="#/history"]');
      container.innerHTML = '';
      
      const header = document.createElement('div');
      header.className = 'flex items-center justify-between mb-3';
      const title = document.createElement('h1');
      title.className = 'text-lg font-light sumi-text';
      title.style.letterSpacing = '0.05em';
      title.textContent = 'トレーニング履歴';
      header.appendChild(title);
      const homeButton = document.createElement('button');
      homeButton.type = 'button';
      homeButton.className = 'flex items-center gap-1 text-sm font-light sumi-text-light hover:sumi-text transition min-h-[44px] px-3';
      homeButton.innerHTML = '← ホーム';
      homeButton.addEventListener('click', () => navigate('#/dashboard'));
      header.appendChild(homeButton);
      container.appendChild(header);
      
      if (state.history.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'section-card bg-white p-6 text-center';
        empty.innerHTML = `
          <p class="text-sm sumi-text-light font-light">まだ履歴がありません</p>
          <p class="text-xs sumi-text-light font-light mt-2">トレーニングを完了すると履歴が記録されます</p>
        `;
        container.appendChild(empty);
        return;
      }
      
      const list = document.createElement('div');
      list.className = 'space-y-3';
      
      state.history.forEach((workout, workoutIndex) => {
        const card = document.createElement('article');
        card.className = 'section-card bg-white p-4 space-y-3';
        
        const header = document.createElement('div');
        header.className = 'flex items-start justify-between gap-3';
        const date = new Date(workout.date);
        const dateStr = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
        const headerLeft = document.createElement('div');
        headerLeft.className = 'min-w-0';
        headerLeft.innerHTML = `
          <p class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${dateStr}</p>
          <p class="text-xs font-light sumi-text-light">${workout.items.length}種目</p>
        `;
        header.appendChild(headerLeft);
        
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'flex gap-2';
        
        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
        editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
        editBtn.textContent = '編集';
        editBtn.addEventListener('click', () => {
          loadHistoryForEdit(workoutIndex);
        });
        buttonGroup.appendChild(editBtn);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
        deleteBtn.style.cssText = 'background-color: rgba(254, 226, 226, 0.5); color: #dc2626; border-color: rgba(220, 38, 38, 0.3); letter-spacing: 0.05em;';
        deleteBtn.textContent = '削除';
        deleteBtn.addEventListener('click', () => {
          deleteWorkout(workoutIndex);
        });
        buttonGroup.appendChild(deleteBtn);
        
        header.appendChild(buttonGroup);
        card.appendChild(header);
        
        const itemsList = document.createElement('div');
        itemsList.className = 'space-y-2';
        
        const sortedItems = [...workout.items].sort((a, b) => a.order - b.order);
        const processedGroups = new Set();
        
        sortedItems.forEach(item => {
          if (item.mode === 'superset') {
            if (!item.groupId || processedGroups.has(item.groupId)) return;
            const groupItems = sortedItems.filter(candidate => candidate.groupId === item.groupId);
            processedGroups.add(item.groupId);
            itemsList.appendChild(buildHistorySuperset(groupItems));
          } else {
            itemsList.appendChild(buildHistorySingle(item));
          }
        });
        
        card.appendChild(itemsList);
        
        // メモを表示
        if (workout.memo && workout.memo.trim()) {
          const memoDiv = document.createElement('div');
          memoDiv.className = 'p-3 rounded-lg border border-dashed';
          memoDiv.style.cssText = 'border-color: rgba(212, 175, 55, 0.3); background-color: rgba(245, 237, 214, 0.1);';
          const memoLabel = document.createElement('p');
          memoLabel.className = 'text-xs font-light mb-1';
          memoLabel.style.color = 'var(--color-gold)';
          memoLabel.textContent = 'メモ';
          const memoText = document.createElement('p');
          memoText.className = 'text-sm font-light sumi-text whitespace-pre-wrap';
          memoText.textContent = workout.memo;
          memoDiv.appendChild(memoLabel);
          memoDiv.appendChild(memoText);
          card.appendChild(memoDiv);
        }
        
        list.appendChild(card);
      });
      
      container.appendChild(list);
    }
    
    function buildHistorySingle(item) {
      const div = document.createElement('div');
      div.className = 'p-3 rounded-lg border border-neutral-200/40';
      
      const partLabel = state.master.parts.find(p => p.id === item.part)?.label ?? '';
      const header = document.createElement('div');
      header.className = 'flex items-start justify-between gap-2 mb-2';
      header.innerHTML = `
        <div class="min-w-0">
          <p class="text-sm font-light sumi-text" style="letter-spacing: 0.02em;">${item.exercise}</p>
          <p class="text-xs font-light sumi-text-light">${partLabel}</p>
        </div>
        <div class="text-xs font-light sumi-text-light text-right min-w-0 truncate">
          ${[item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ')}
        </div>
      `;
      div.appendChild(header);
      
      const workSets = item.sets.filter(s => !s.warmup);
      const setsText = workSets.map(s => {
        if (s.seconds != null) return `${s.seconds}秒`;
        const parts = [];
        if (s.weight != null) parts.push(`${s.weight}kg`);
        if (s.repsU != null) parts.push(`×${s.repsU}`);
        return parts.join('');
      }).join(', ');
      
      const setsDiv = document.createElement('div');
      setsDiv.className = 'text-xs font-light sumi-text-light';
      setsDiv.textContent = setsText || 'セットなし';
      div.appendChild(setsDiv);
      
      return div;
    }
    
    function buildHistorySuperset(groupItems) {
      const sorted = [...groupItems].sort((a, b) => a.order - b.order);
      const labels = ['A', 'B', 'C'];
      const title = `(SS) ${sorted.map(item => item.exercise).join(' + ')}`;
      
      const div = document.createElement('div');
      div.className = 'p-3 rounded-lg border border-neutral-200/40';
      
      const header = document.createElement('div');
      header.className = 'flex items-start justify-between gap-2 mb-2';
      header.innerHTML = `
        <div class="min-w-0">
          <p class="text-sm font-light sumi-text" style="letter-spacing: 0.02em;">${title}</p>
          <p class="text-xs font-light sumi-text-light">${sorted.map((item, index) => `${labels[index]}. ${state.master.parts.find(p => p.id === item.part)?.label ?? ''}`).join(' / ')}</p>
        </div>
      `;
      div.appendChild(header);
      
      const rounds = buildSupersetRounds(sorted);
      const roundsText = `${rounds.length}ラウンド`;
      const roundsDiv = document.createElement('div');
      roundsDiv.className = 'text-xs font-light sumi-text-light';
      roundsDiv.textContent = roundsText;
      div.appendChild(roundsDiv);
      
      return div;
    }

    // LocalStorage functions
    function saveHistory() {
      try {
        localStorage.setItem('muscleRoutineHistory', JSON.stringify(state.history));
        localStorage.setItem('muscleRoutineHistoryVersion', '1');
      } catch (e) {
        console.error('Failed to save history:', e);
      }
    }

    function loadHistory() {
      try {
        const saved = localStorage.getItem('muscleRoutineHistory');
        if (saved) {
          state.history = JSON.parse(saved);
        }
      } catch (e) {
        console.error('Failed to load history:', e);
        state.history = [];
      }
    }

    function deleteWorkout(workoutIndex) {
      const workout = state.history[workoutIndex];
      const date = new Date(workout.date);
      const dateStr = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
      
      const confirmed = confirm(`${dateStr}のトレーニング履歴を削除しますか？\nこの操作は元に戻せません。`);
      if (!confirmed) return;
      
      // 履歴から削除
      state.history.splice(workoutIndex, 1);
      saveHistory();
      
      // 画面を再描画
      render();
      
      alert('履歴を削除しました。');
    }
    
    function loadHistoryForEdit(historyIndex) {
      // 履歴データをstate.dayに読み込む
      const workout = state.history[historyIndex];
      state.day = {
        date: workout.date,
        memo: workout.memo || '',
        items: JSON.parse(JSON.stringify(workout.items)) // deep copy
      };
      
      // 編集モードを設定
      uiState.editingHistoryIndex = historyIndex;
      
      // 今日のトレーニング画面に遷移
      navigate('#/today');
    }

    function completeWorkout() {
      const isEditing = uiState.editingHistoryIndex !== null;
      
      if (isEditing) {
        // 編集モード：履歴を更新
        const workout = {
          date: state.day.date,
          memo: state.day.memo || '',
          items: JSON.parse(JSON.stringify(state.day.items)), // deep copy
          completedAt: state.history[uiState.editingHistoryIndex].completedAt,
          updatedAt: new Date().toISOString()
        };
        state.history[uiState.editingHistoryIndex] = workout;
        saveHistory();
        
        // 編集モードを解除
        uiState.editingHistoryIndex = null;
        
        // 新しい日のデータを初期化
        state.day = {
          date: new Date().toISOString().slice(0, 10),
          memo: '',
          items: []
        };
        
        alert('履歴を更新しました！');
        navigate('#/history'); // 履歴画面に戻る
      } else {
        // 通常モード：今日のトレーニングをhistoryに追加
        const workout = {
          date: state.day.date,
          memo: state.day.memo || '',
          items: JSON.parse(JSON.stringify(state.day.items)), // deep copy
          completedAt: new Date().toISOString()
        };
        state.history.unshift(workout); // 最新を先頭に
        saveHistory();
        
        // 新しい日のデータを初期化
        state.day = {
          date: new Date().toISOString().slice(0, 10),
          memo: '',
          items: []
        };
        
        clearDraft(); // 下書きをクリア
        alert('トレーニングを完了しました！\n引き続き編集できます。');
        render(); // 画面を再描画
      }
    }

    function renderSettings() {
      const container = document.querySelector('[data-route="#/settings"]');
      container.innerHTML = '';
      
      // ヘッダー
      const header = document.createElement('div');
      header.className = 'flex items-center justify-between mb-3';
      const title = document.createElement('h1');
      title.className = 'text-lg font-light sumi-text';
      title.style.letterSpacing = '0.05em';
      title.textContent = '設定';
      header.appendChild(title);
      const homeButton = document.createElement('button');
      homeButton.type = 'button';
      homeButton.className = 'flex items-center gap-1 text-sm font-light sumi-text-light hover:sumi-text transition min-h-[44px] px-3';
      homeButton.innerHTML = '← ホーム';
      homeButton.addEventListener('click', () => navigate('#/dashboard'));
      header.appendChild(homeButton);
      container.appendChild(header);
      
      // データ管理セクション
      const dataSection = document.createElement('section');
      dataSection.className = 'section-card bg-white p-4 space-y-4';
      
      const dataSectionTitle = document.createElement('h2');
      dataSectionTitle.className = 'text-base font-light sumi-text';
      dataSectionTitle.style.letterSpacing = '0.05em';
      dataSectionTitle.textContent = 'データ管理';
      dataSection.appendChild(dataSectionTitle);
      
      // エクスポートボタン
      const exportBtn = document.createElement('button');
      exportBtn.type = 'button';
      exportBtn.className = 'w-full ios-card bg-white px-4 py-3 text-sm font-light transition min-h-[44px] border';
      exportBtn.style.cssText = 'border-color: rgba(212, 175, 55, 0.3); color: var(--color-gold); letter-spacing: 0.05em;';
      exportBtn.textContent = '📥 データをエクスポート';
      exportBtn.addEventListener('click', exportData);
      dataSection.appendChild(exportBtn);
      
      // インポートボタン
      const importBtn = document.createElement('button');
      importBtn.type = 'button';
      importBtn.className = 'w-full ios-card bg-white px-4 py-3 text-sm font-light transition min-h-[44px] border';
      importBtn.style.cssText = 'border-color: rgba(212, 175, 55, 0.3); color: var(--color-gold); letter-spacing: 0.05em;';
      importBtn.textContent = '📤 データをインポート';
      importBtn.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) importData(file);
        });
        input.click();
      });
      dataSection.appendChild(importBtn);
      
      // データクリアボタン
      const clearBtn = document.createElement('button');
      clearBtn.type = 'button';
      clearBtn.className = 'w-full ios-card bg-white px-4 py-3 text-sm font-light transition min-h-[44px] border';
      clearBtn.style.cssText = 'border-color: rgba(220, 38, 38, 0.3); color: #dc2626; letter-spacing: 0.05em;';
      clearBtn.textContent = '🗑️ すべてのデータを削除';
      clearBtn.addEventListener('click', clearAllData);
      dataSection.appendChild(clearBtn);
      
      container.appendChild(dataSection);
      
      // カスタムデータ管理セクション
      const customDataSection = document.createElement('section');
      customDataSection.className = 'section-card bg-white p-4 space-y-4';
      
      const customDataSectionTitle = document.createElement('h2');
      customDataSectionTitle.className = 'text-base font-light sumi-text';
      customDataSectionTitle.style.letterSpacing = '0.05em';
      customDataSectionTitle.textContent = 'カスタムデータ管理';
      customDataSection.appendChild(customDataSectionTitle);
      
      // カスタムデータ管理ボタン
      const manageCustomDataBtn = document.createElement('button');
      manageCustomDataBtn.type = 'button';
      manageCustomDataBtn.className = 'w-full ios-card bg-white px-4 py-3 text-sm font-light transition min-h-[44px] border';
      manageCustomDataBtn.style.cssText = 'border-color: rgba(139, 92, 246, 0.3); color: var(--color-purple); letter-spacing: 0.05em;';
      manageCustomDataBtn.textContent = '⚙️ カスタムデータを管理';
      manageCustomDataBtn.addEventListener('click', showCustomDataManagement);
      customDataSection.appendChild(manageCustomDataBtn);
      
      container.appendChild(customDataSection);
      
      // アプリ情報セクション
      const infoSection = document.createElement('section');
      infoSection.className = 'section-card bg-white p-4 space-y-3';
      
      const infoSectionTitle = document.createElement('h2');
      infoSectionTitle.className = 'text-base font-light sumi-text';
      infoSectionTitle.style.letterSpacing = '0.05em';
      infoSectionTitle.textContent = 'アプリ情報';
      infoSection.appendChild(infoSectionTitle);
      
      const versionInfo = document.createElement('div');
      versionInfo.className = 'text-sm font-light sumi-text-light space-y-1';
      versionInfo.innerHTML = `
        <p>バージョン: 1.0.0</p>
        <p>ビルドタグ: PHASE-5-20240529</p>
        <p class="text-xs mt-2">開発: Manus AI</p>
      `;
      infoSection.appendChild(versionInfo);
      
      container.appendChild(infoSection);
    }
    
    function exportData() {
      try {
        const exportObj = {
          version: '1.0.0',
          exportDate: new Date().toISOString(),
          data: {
            history: state.history,
            day: state.day
          }
        };
        
        const jsonStr = JSON.stringify(exportObj, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const dateStr = new Date().toISOString().slice(0, 10);
        a.download = `muscle-routine-backup-${dateStr}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        alert('データをエクスポートしました！');
      } catch (e) {
        alert('エクスポートに失敗しました: ' + e.message);
      }
    }
    
    function importData(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importObj = JSON.parse(e.target.result);
          
          if (!importObj.data || !importObj.data.history) {
            throw new Error('無効なデータ形式です');
          }
          
          const confirmed = confirm('データをインポートしますか？\n現在のデータは上書きされます。');
          if (!confirmed) return;
          
          state.history = importObj.data.history || [];
          if (importObj.data.day) {
            state.day = importObj.data.day;
          }
          
          saveHistory();
          render();
          
          alert(`データをインポートしました！\n履歴: ${state.history.length}件`);
        } catch (e) {
          alert('インポートに失敗しました: ' + e.message);
        }
      };
      reader.readAsText(file);
    }
    
    function showCustomDataManagement() {
      const modal = document.getElementById('customDataModal');
      if (!modal) {
        const newModal = document.createElement('div');
        newModal.id = 'customDataModal';
        newModal.className = 'fixed inset-0 bg-black/30 flex items-center justify-center p-4 z-50';
        newModal.style.display = 'none';
        newModal.innerHTML = `
          <div class="bg-white rounded-2xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto">
            <div class="sticky top-0 bg-white border-b border-neutral-200/40 px-6 py-4 flex items-center justify-between">
              <h2 class="text-lg font-light sumi-text" style="letter-spacing: 0.05em;">カスタムデータ管理</h2>
              <button type="button" class="text-2xl text-neutral-400 hover:text-neutral-600 transition min-h-[44px] min-w-[44px]" onclick="document.getElementById('customDataModal').style.display='none'">&times;</button>
            </div>
            <div id="customDataContent" class="p-6 space-y-6"></div>
          </div>
        `;
        document.body.appendChild(newModal);
      }
      
      renderCustomDataContent();
      document.getElementById('customDataModal').style.display = 'flex';
    }
    
    function renderCustomDataContent() {
      const content = document.getElementById('customDataContent');
      content.innerHTML = '';
      
      const categories = [
        { key: 'gear', label: '器具', icon: '🏋️' },
        { key: 'attachments', label: 'アタッチメント', icon: '🔗' },
        { key: 'angles', label: '角度', icon: '📊' },
        { key: 'positions', label: 'ポジション', icon: '🧘' }
      ];
      
      categories.forEach(category => {
        const items = state.customMaster[category.key] || [];
        
        const section = document.createElement('div');
        section.className = 'space-y-3';
        
        const header = document.createElement('div');
        header.className = 'flex items-center justify-between gap-2';
        
        const headerLeft = document.createElement('div');
        headerLeft.className = 'flex items-center gap-2';
        headerLeft.innerHTML = `
          <span class="text-xl">${category.icon}</span>
          <h3 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">${category.label}</h3>
          <span class="text-xs font-light sumi-text-light">(${items.length}件)</span>
        `;
        header.appendChild(headerLeft);
        
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
        addBtn.style.cssText = 'background-color: rgba(139, 92, 246, 0.1); color: var(--color-purple); border-color: rgba(139, 92, 246, 0.3); letter-spacing: 0.05em;';
        addBtn.textContent = '＋ 追加';
        addBtn.addEventListener('click', () => addCustomData(category.key, category.label));
        header.appendChild(addBtn);
        
        section.appendChild(header);
        
        if (items.length === 0) {
          const emptyMsg = document.createElement('p');
          emptyMsg.className = 'text-sm font-light sumi-text-light pl-8';
          emptyMsg.textContent = 'カスタムデータはありません';
          section.appendChild(emptyMsg);
        } else {
          const list = document.createElement('div');
          list.className = 'space-y-2 pl-8';
          
          items.forEach((item, index) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'flex items-center justify-between gap-2 p-3 rounded-lg border border-neutral-200/40 bg-neutral-50/30';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'text-sm font-light sumi-text';
            nameSpan.textContent = item;
            itemDiv.appendChild(nameSpan);
            
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'flex gap-2';
            
            const editBtn = document.createElement('button');
            editBtn.type = 'button';
            editBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
            editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
            editBtn.textContent = '編集';
            editBtn.addEventListener('click', () => editCustomData(category.key, index, item));
            buttonGroup.appendChild(editBtn);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
            deleteBtn.style.cssText = 'background-color: rgba(254, 226, 226, 0.5); color: #dc2626; border-color: rgba(220, 38, 38, 0.3); letter-spacing: 0.05em;';
            deleteBtn.textContent = '削除';
            deleteBtn.addEventListener('click', () => deleteCustomData(category.key, index, item));
            buttonGroup.appendChild(deleteBtn);
            
            itemDiv.appendChild(buttonGroup);
            list.appendChild(itemDiv);
          });
          
          section.appendChild(list);
        }
        
        content.appendChild(section);
      });
      
      // 種目は部位ごとに表示
      const exercisesSection = document.createElement('div');
      exercisesSection.className = 'space-y-3';
      
      const exercisesHeader = document.createElement('div');
      exercisesHeader.className = 'flex items-center gap-2';
      const totalExercises = Object.values(state.customMaster.exercises || {}).reduce((sum, arr) => sum + arr.length, 0);
      exercisesHeader.innerHTML = `
        <span class="text-xl">🏋️‍♂️</span>
        <h3 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">種目</h3>
        <span class="text-xs font-light sumi-text-light">(${totalExercises}件)</span>
      `;
      exercisesSection.appendChild(exercisesHeader);
      
      if (totalExercises === 0) {
        const emptyMsg = document.createElement('p');
        emptyMsg.className = 'text-sm font-light sumi-text-light pl-8';
        emptyMsg.textContent = 'カスタム種目はありません';
        exercisesSection.appendChild(emptyMsg);
      } else {
        const partsList = document.createElement('div');
        partsList.className = 'space-y-4 pl-8';
        
        state.master.parts.forEach(part => {
          const exercises = state.customMaster.exercises[part.id] || [];
          if (exercises.length === 0) return;
          
          const partDiv = document.createElement('div');
          partDiv.className = 'space-y-2';
          
          const partHeaderDiv = document.createElement('div');
          partHeaderDiv.className = 'flex items-center justify-between gap-2';
          
          const partHeader = document.createElement('h4');
          partHeader.className = 'text-sm font-light sumi-text';
          partHeader.style.letterSpacing = '0.05em';
          partHeader.textContent = `${part.label} (${exercises.length}件)`;
          partHeaderDiv.appendChild(partHeader);
          
          const addExerciseBtn = document.createElement('button');
          addExerciseBtn.type = 'button';
          addExerciseBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
          addExerciseBtn.style.cssText = 'background-color: rgba(139, 92, 246, 0.1); color: var(--color-purple); border-color: rgba(139, 92, 246, 0.3); letter-spacing: 0.05em;';
          addExerciseBtn.textContent = '＋ 追加';
          addExerciseBtn.addEventListener('click', () => addCustomExercise(part.id, part.label));
          partHeaderDiv.appendChild(addExerciseBtn);
          
          partDiv.appendChild(partHeaderDiv);
          
          const exercisesList = document.createElement('div');
          exercisesList.className = 'space-y-2';
          
          exercises.forEach((exercise, index) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'flex items-center justify-between gap-2 p-3 rounded-lg border border-neutral-200/40 bg-neutral-50/30';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'text-sm font-light sumi-text';
            nameSpan.textContent = exercise;
            itemDiv.appendChild(nameSpan);
            
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'flex gap-2';
            
            const editBtn = document.createElement('button');
            editBtn.type = 'button';
            editBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
            editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
            editBtn.textContent = '編集';
            editBtn.addEventListener('click', () => editCustomExercise(part.id, index, exercise));
            buttonGroup.appendChild(editBtn);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
            deleteBtn.style.cssText = 'background-color: rgba(254, 226, 226, 0.5); color: #dc2626; border-color: rgba(220, 38, 38, 0.3); letter-spacing: 0.05em;';
            deleteBtn.textContent = '削除';
            deleteBtn.addEventListener('click', () => deleteCustomExercise(part.id, index, exercise));
            buttonGroup.appendChild(deleteBtn);
            
            itemDiv.appendChild(buttonGroup);
            exercisesList.appendChild(itemDiv);
          });
          
          partDiv.appendChild(exercisesList);
          partsList.appendChild(partDiv);
        });
        
        exercisesSection.appendChild(partsList);
      }
      
      content.appendChild(exercisesSection);
    }
    
    function editCustomData(categoryKey, index, currentName) {
      const newName = prompt(`新しい名前を入力してください:`, currentName);
      if (!newName || newName.trim() === '') return;
      if (newName === currentName) return;
      
      state.customMaster[categoryKey][index] = newName.trim();
      saveCustomMasterData();
      renderCustomDataContent();
    }
    
    function deleteCustomData(categoryKey, index, name) {
      const confirmed = confirm(`「${name}」を削除しますか？`);
      if (!confirmed) return;
      
      state.customMaster[categoryKey].splice(index, 1);
      saveCustomMasterData();
      renderCustomDataContent();
    }
    
    function editCustomExercise(partId, index, currentName) {
      const newName = prompt(`新しい種目名を入力してください:`, currentName);
      if (!newName || newName.trim() === '') return;
      if (newName === currentName) return;
      
      state.customMaster.exercises[partId][index] = newName.trim();
      saveCustomMasterData();
      renderCustomDataContent();
    }
    
    function deleteCustomExercise(partId, index, name) {
      const confirmed = confirm(`「${name}」を削除しますか？`);
      if (!confirmed) return;
      
      state.customMaster.exercises[partId].splice(index, 1);
      saveCustomMasterData();
      renderCustomDataContent();
    }
    
    function addCustomData(categoryKey, categoryLabel) {
      const newName = prompt(`新しい${categoryLabel}を入力してください:`);
      if (!newName || newName.trim() === '') return;
      
      if (!state.customMaster[categoryKey]) {
        state.customMaster[categoryKey] = [];
      }
      
      // 重複チェック
      if (state.customMaster[categoryKey].includes(newName.trim())) {
        alert('すでに登録されています');
        return;
      }
      
      state.customMaster[categoryKey].push(newName.trim());
      saveCustomMasterData();
      renderCustomDataContent();
    }
    
    function addCustomExercise(partId, partLabel) {
      const newName = prompt(`${partLabel}の新しい種目を入力してください:`);
      if (!newName || newName.trim() === '') return;
      
      if (!state.customMaster.exercises[partId]) {
        state.customMaster.exercises[partId] = [];
      }
      
      // 重複チェック
      if (state.customMaster.exercises[partId].includes(newName.trim())) {
        alert('すでに登録されています');
        return;
      }
      
      state.customMaster.exercises[partId].push(newName.trim());
      saveCustomMasterData();
      renderCustomDataContent();
    }
    
    function clearAllData() {
      const confirmed = confirm('本当にすべてのデータを削除しますか？\nこの操作は元に戻せません。');
      if (!confirmed) return;
      
      const doubleConfirmed = confirm('最終確認: 本当に削除しますか？');
      if (!doubleConfirmed) return;
      
      try {
        localStorage.clear();
        state.history = [];
        state.day = {
          date: new Date().toISOString().slice(0, 10),
          memo: '',
          items: []
        };
        render();
        alert('すべてのデータを削除しました。');
        navigate('#/dashboard');
      } catch (e) {
        alert('削除に失敗しました: ' + e.message);
      }
    }

    // 自動保存機能
    let autoSaveTimeout = null;

    function autoSaveDraft() {
      // デバウンス処理
      if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
      
      autoSaveTimeout = setTimeout(() => {
        try {
          // activeEditSession が存在する場合、変更をstate.day.itemsに反映
          if (activeEditSession && activeEditSession.itemId) {
            const item = state.day.items.find(it => it.id === activeEditSession.itemId);
            if (!item) {
              console.warn('Item not found for auto-save');
              return;
            }
            item.sets = activeEditSession.rows.flatMap(row => {
              const sets = [{
                id: row.id,
                weight: row.weight,
                repsU: row.repsU,
                repsA: row.repsA,
                seconds: row.seconds,
                warmup: row.warmup,
                round: row.round,
                memo: row.memo,
                drop: false,
                ts: Date.now()
              }];
              row.drops.forEach(drop => {
                sets.push({
                  id: drop.id,
                  weight: drop.weight,
                  repsU: drop.repsU,
                  repsA: drop.repsA,
                  seconds: drop.seconds,
                  warmup: drop.warmup,
                  round: drop.round,
                  drop: true,
                  ts: Date.now()
                });
              });
              return sets;
            });
          }
          
          const draft = {
            date: state.day.date,
            items: state.day.items,
            memo: state.day.memo,
            timestamp: Date.now()
          };
          localStorage.setItem('draft_day', JSON.stringify(draft));
          console.log('Draft auto-saved at', new Date().toLocaleTimeString());
        } catch (e) {
          console.error('Failed to auto-save draft:', e);
        }
      }, 300);
    }

    function restoreDraft() {
      try {
        const draftStr = localStorage.getItem('draft_day');
        if (!draftStr) return false;
        
        const draft = JSON.parse(draftStr);
        const today = new Date().toISOString().slice(0, 10);
        
        // 日付が一致する場合のみ復元
        if (draft.date === today) {
          state.day = {
            date: draft.date,
            items: draft.items,
            memo: draft.memo
          };
          console.log('Draft restored from', new Date(draft.timestamp).toLocaleString());
          return true;
        } else {
          // 古い下書きを削除
          localStorage.removeItem('draft_day');
          return false;
        }
      } catch (e) {
        console.error('Failed to restore draft:', e);
        return false;
      }
    }

    function clearDraft() {
      try {
        localStorage.removeItem('draft_day');
        console.log('Draft cleared');
      } catch (e) {
        console.error('Failed to clear draft:', e);
      }
    }

    // カスタムマスターデータの保存・読み込み
    function loadCustomMaster() {
      try {
        const stored = localStorage.getItem('customMaster');
        if (stored) {
          const custom = JSON.parse(stored);
          state.customMaster = {
            exercises: custom.exercises || {},
            gear: custom.gear || [],
            attachments: custom.attachments || [],
            angles: custom.angles || [],
            positions: custom.positions || []
          };
          console.log('Custom master data loaded');
        }
      } catch (e) {
        console.error('Failed to load custom master data:', e);
      }
    }

    function saveCustomMaster() {
      try {
        localStorage.setItem('customMaster', JSON.stringify(state.customMaster));
        console.log('Custom master data saved');
      } catch (e) {
        console.error('Failed to save custom master data:', e);
      }
    }

    // カスタムマスターデータの取得（既存データと統合）
    function getAllExercises(part) {
      const defaults = state.master.exercises[part] || [];
      const custom = state.customMaster.exercises[part] || [];
      return [...custom, ...defaults];
    }

    function getAllGear() {
      const defaults = state.master.gear;
      const custom = state.customMaster.gear;
      return [...custom, ...defaults];
    }

    function getAllAttachments() {
      const defaults = state.master.attachments;
      const custom = state.customMaster.attachments;
      return [...custom, ...defaults];
    }

    function getAllAngles() {
      const defaults = state.master.angles;
      const custom = state.customMaster.angles;
      return [...custom, ...defaults];
    }

    function getAllPositions() {
      const defaults = state.master.positions;
      const custom = state.customMaster.positions;
      return [...custom, ...defaults];
    }

    // カスタムマスターデータの追加
    function addCustomExercise(part, name) {
      if (!state.customMaster.exercises[part]) {
        state.customMaster.exercises[part] = [];
      }
      const allExercises = getAllExercises(part);
      if (allExercises.includes(name)) {
        alert('この種目は既に存在します。');
        return false;
      }
      state.customMaster.exercises[part].push(name);
      saveCustomMaster();
      return true;
    }

    function addCustomGear(name) {
      const allGear = getAllGear();
      if (allGear.includes(name)) {
        alert('この器具は既に存在します。');
        return false;
      }
      state.customMaster.gear.push(name);
      saveCustomMaster();
      return true;
    }

    function addCustomAttachment(name) {
      const allAttachments = getAllAttachments();
      if (allAttachments.includes(name)) {
        alert('このアタッチメントは既に存在します。');
        return false;
      }
      state.customMaster.attachments.push(name);
      saveCustomMaster();
      return true;
    }

    function addCustomAngle(name) {
      const allAngles = getAllAngles();
      if (allAngles.includes(name)) {
        alert('この角度は既に存在します。');
        return false;
      }
      state.customMaster.angles.push(name);
      saveCustomMaster();
      return true;
    }

    function addCustomPosition(name) {
      const allPositions = getAllPositions();
      if (allPositions.includes(name)) {
        alert('このポジションは既に存在します。');
        return false;
      }
      state.customMaster.positions.push(name);
      saveCustomMaster();
      return true;
    }

    // カスタムモーダル関数
    function showCustomModal(title, placeholder, callback) {
      const modal = document.getElementById('customModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalInput = document.getElementById('modalInput');
      const modalError = document.getElementById('modalError');
      
      modalTitle.textContent = title;
      modalInput.placeholder = placeholder;
      modalInput.value = '';
      modalError.textContent = '';
      modalError.classList.add('hidden');
      
      modal.classList.remove('hidden');
      modalInput.focus();
      
      // キャンセルボタン
      document.getElementById('modalCancel').onclick = () => {
        modal.classList.add('hidden');
        callback(null);
      };
      
      // 追加ボタン
      document.getElementById('modalAdd').onclick = () => {
        const value = modalInput.value.trim();
        if (!value) {
          modalError.textContent = '入力してください';
          modalError.classList.remove('hidden');
          return;
        }
        modal.classList.add('hidden');
        callback(value);
      };
      
      // Enterキーで追加
      modalInput.onkeydown = (e) => {
        if (e.key === 'Enter') {
          document.getElementById('modalAdd').click();
        } else if (e.key === 'Escape') {
          document.getElementById('modalCancel').click();
        }
      };
    }

    function initialize() {
      loadHistory();
      loadCustomMaster(); // カスタムマスターデータを読み込み
      restoreDraft(); // 下書きを復元
      handleNavigation(window.location.hash || '#/dashboard');
    }

    initialize();
  </script>
  
  <!-- カスタムモーダル -->
  <div id="customModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-2xl p-6 m-4 max-w-sm w-full shadow-2xl">
      <h3 id="modalTitle" class="text-lg font-bold mb-4"></h3>
      <input id="modalInput" type="text" class="w-full px-4 py-3 border-2 border-gray-300 rounded-xl focus:border-yellow-600 focus:outline-none text-lg mb-2">
      <p id="modalError" class="text-red-600 text-sm mb-4 hidden"></p>
      <div class="flex gap-3">
        <button id="modalCancel" class="flex-1 px-4 py-3 bg-gray-200 text-gray-800 rounded-xl font-semibold hover:bg-gray-300 transition">
          キャンセル
        </button>
        <button id="modalAdd" class="flex-1 px-4 py-3 bg-yellow-600 text-white rounded-xl font-semibold hover:bg-yellow-700 transition">
          追加
        </button>
      </div>
    </div>
  </div>
</body>
</html>
