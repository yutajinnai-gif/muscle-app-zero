<!DOCTYPE html>
<html lang="ja" class="h-full bg-neutral-50">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BUILD_TAG=PHASE-5-20240529 | Muscle Routine</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* カラーパレット: 白・墨・淡い金 */
    :root {
      --color-sumi-dark: #1A1A1A;
      --color-sumi-mid: #404040;
      --color-sumi-light: #737373;
      --color-gold: #D4AF37;
      --color-gold-light: #E8D4A0;
      --color-gold-pale: #F5EDD6;
      --color-white: #FFFFFF;
      --color-off-white: #FAFAFA;
    }
    
    html, body { height: 100%; }
    body { 
      overflow-x: hidden;
      letter-spacing: 0.01em;
      line-height: 1.6;
    }
    
    :focus-visible { 
      outline: 2px solid var(--color-gold); 
      outline-offset: 2px; 
    }
    
    ::-webkit-scrollbar { width: 0; height: 0; }
    
    .ios-card { 
      border-radius: 20px; 
      box-shadow: 0 4px 16px -4px rgba(26, 26, 26, 0.08);
      transition: all 0.2s ease;
    }
    
    .ios-card:hover {
      box-shadow: 0 6px 20px -4px rgba(26, 26, 26, 0.12);
    }
    
    .section-card { 
      border-radius: 16px; 
      box-shadow: 0 2px 12px -2px rgba(26, 26, 26, 0.06);
      border: 1px solid rgba(115, 115, 115, 0.08);
    }
    
    .gold-accent {
      background: linear-gradient(135deg, var(--color-gold-pale) 0%, var(--color-white) 100%);
    }
    
    .sumi-text { color: var(--color-sumi-dark); }
    .sumi-text-mid { color: var(--color-sumi-mid); }
    .sumi-text-light { color: var(--color-sumi-light); }
  </style>
</head>
<body class="h-full sumi-text transition-colors duration-300">
  <div id="error-banner" class="hidden fixed top-0 left-0 right-0 z-50 flex items-center gap-2 bg-red-600 text-white px-4 py-3 shadow-lg">
    <span class="font-semibold">エラー</span>
    <span id="error-message" class="text-sm min-w-0 truncate"></span>
    <button type="button" id="error-dismiss" class="ml-auto text-xs font-semibold bg-white/15 hover:bg-white/25 rounded-full px-3 py-1 focus-visible:ring-2 focus-visible:ring-white/70 focus:outline-none min-h-[36px]">閉じる</button>
  </div>

  <main class="h-full max-w-3xl mx-auto px-4 pb-16 pt-20 flex flex-col gap-8 bg-transparent">
    <header class="space-y-2">
      <h1 class="text-3xl font-light tracking-wide sumi-text" style="letter-spacing: 0.05em;">筋トレ記録</h1>
      <p class="text-sm sumi-text-light font-light">自分の変化を美しく記録するツール</p>
    </header>

    <section data-route="#/dashboard" class="route-view hidden flex flex-col gap-6 bg-neutral-50"></section>
    <section data-route="#/today" class="route-view hidden flex flex-col gap-6 bg-violet-50"></section>
    <section data-route="#/exercise" class="route-view hidden flex flex-col gap-6 bg-orange-50"></section>
    <section data-route="#/set" class="route-view hidden flex flex-col gap-6 bg-orange-50"></section>
    <section data-route="#/history" class="route-view hidden flex flex-col gap-6 bg-amber-50"></section>
    <section data-route="#/settings" class="route-view hidden flex flex-col gap-6 bg-sky-50"></section>
  </main>

  <script>
    const state = {
      schemaVersion: 2,
      master: {
        parts: [
          { id: 'chest', label: '胸' },
          { id: 'back', label: '背中' },
          { id: 'shoulder', label: '肩' },
          { id: 'arm', label: '腕' },
          { id: 'leg', label: '脚' },
          { id: 'core', label: '体幹' },
          { id: 'full', label: '全身' }
        ],
        exercises: {
          chest: ['フライ', 'プレス', 'ベンチプレス', 'チェストプレス', 'ディップス', 'プッシュアップ'],
          back: ['チンニング', 'デッドリフト', 'ラットプルダウン', 'プーリーロー', 'ベントオーバーロー', 'ローイング', 'プルオーバー'],
          shoulder: ['ショルダープレス', 'フロントレイズ', 'サイドレイズ', 'リアデルト', 'リアレイズ', 'フェイスプル', 'アーノルドプレス', 'ミリタリープレス', 'パーシャルサイドレイズ'],
          arm: ['アームカール', 'スカルクラッシャー', 'ハンマーカール', 'プレスダウン', 'オーバーヘッドプレス', 'キックバック', 'リバースプッシュ', '志澤カール', 'スパイダーカール', 'ナロープレス', 'プリチャーカール'],
          leg: ['カール', 'エクステンション', 'プレス', 'スクワット', 'インナーサイ', 'アウターサイ', 'デッドリフト', 'ブルガリアン', 'ヒップスラスト'],
          core: ['クランチ', 'レッグレイズ', 'ベンチレッグレイズ'],
          full: []
        },
        gear: ['-', 'ケーブル', 'ダンベル', 'バーベル', 'スミス', 'マシン', 'ペックマシン', '自重', 'プレート', 'ゴムチューブ', 'イージーバー'],
        attachments: ['-', 'マグ(ナロー)', 'マグ(ワイド)', 'マグ(ミドル)', 'ロープ', 'Vバー', 'イージーバー', 'バンド', 'ワイドバー', 'ショートバー', 'パラレルバー'],
        angles: ['-', 'インクライン', 'デクライン', 'フラット'],
        positions: ['-', 'ワイド', 'ナロー', 'ボックス', 'リバース']
      },
      history: [],
      day: {
        date: new Date().toISOString().slice(0, 10),
        memo: '',
        items: [
          {
            id: createId('item'),
            order: 1,
            mode: 'single',
            groupId: null,
            part: 'chest',
            exercise: 'バーベルベンチプレス',
            gear: 'バーベル',
            attachment: '-',
            angle: 'フラット',
            position: '-',
            timed: false,
            oneHand: false,
            sets: [
              createSet({ weight: 60, repsU: 10, repsA: 0, warmup: true, drop: false, round: null, ts: Date.now() - 7200000 }),
              createSet({ weight: 80, repsU: 8, repsA: 0, warmup: false, drop: false, round: null, ts: Date.now() - 7100000 }),
              createSet({ weight: 60, repsU: 12, repsA: 0, warmup: false, drop: true, round: null, ts: Date.now() - 7090000 })
            ]
          },
          ...createSampleSuperset()
        ]
      }
    };

    const uiState = {
      route: null,
      exerciseForm: createExerciseFormState(),
      currentItemId: null,
      setEditor: null,
      editingHistoryIndex: null
    };

    function createId(prefix) {
      return `${prefix}-${Math.random().toString(36).slice(2, 11)}`;
    }

    function createSet({ weight = null, repsU = null, repsA = null, seconds = null, warmup = false, drop = false, round = null, ts = Date.now() }) {
      return { id: createId('set'), weight, repsU, repsA, seconds, warmup, drop, round, ts };
    }

    function createSampleSuperset() {
      const groupId = createGroupId();
      const now = Date.now();
      const baseTs = now - 3600000;
      const bench = {
        id: createId('item'),
        order: 2,
        mode: 'superset',
        groupId,
        part: 'chest',
        exercise: 'ダンベルフライ',
        gear: 'ダンベル',
        attachment: '-',
        angle: 'フラット',
        position: '-',
        timed: false,
        oneHand: false,
        sets: [
          createSet({ weight: 20, repsU: 12, repsA: 0, warmup: false, drop: false, round: 0, ts: baseTs }),
          createSet({ weight: 14, repsU: 12, repsA: 0, warmup: false, drop: true, round: 0, ts: baseTs + 1000 })
        ]
      };
      const pull = {
        id: createId('item'),
        order: 2.01,
        mode: 'superset',
        groupId,
        part: 'back',
        exercise: 'ラットプルダウン',
        gear: 'マシン',
        attachment: 'ワイドバー',
        angle: '-',
        position: '-',
        timed: false,
        oneHand: false,
        sets: [
          createSet({ weight: 55, repsU: 10, repsA: 0, warmup: false, drop: false, round: 0, ts: baseTs })
        ]
      };
      return [bench, pull];
    }

    function createGroupId() {
      return `grp_${Math.random().toString(36).slice(2, 8)}`;
    }

    function createExerciseFormState() {
      // LocalStorageから前回の設定を読み込む
      const saved = loadLastExerciseSettings();
      if (saved) {
        return saved;
      }
      return {
        superset: false,
        cards: [createExerciseCardState('A')]
      };
    }
    
    function saveLastExerciseSettings(formState) {
      try {
        localStorage.setItem('lastExerciseSettings', JSON.stringify(formState));
      } catch (e) {
        console.error('Failed to save exercise settings:', e);
      }
    }
    
    function loadLastExerciseSettings() {
      try {
        const saved = localStorage.getItem('lastExerciseSettings');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (e) {
        console.error('Failed to load exercise settings:', e);
      }
      return null;
    }
    
    function clearLastExerciseSettings() {
      try {
        localStorage.removeItem('lastExerciseSettings');
      } catch (e) {
        console.error('Failed to clear exercise settings:', e);
      }
    }

    function createExerciseCardState(label) {
      const firstPart = state.master.parts[0]?.id ?? '';
      const firstExercise = (state.master.exercises[firstPart] || [])[0] || '';
      return {
        key: createId('card'),
        label,
        part: firstPart,
        exercise: firstExercise,
        gear: '-',
        attachment: '-',
        angle: '-',
        position: '-',
        timed: false,
        oneHand: false,
        dropset: false
      };
    }

    function sortForDisplay(list) {
      return [...list].sort((a, b) => {
        if (a === '-') return -1;
        if (b === '-') return 1;
        return a.localeCompare(b, 'ja');
      });
    }

    function showError(message) {
      const banner = document.getElementById('error-banner');
      const text = document.getElementById('error-message');
      text.textContent = message;
      banner.classList.remove('hidden');
    }

    window.onerror = function(message, source, lineno, colno) {
      showError(`${message} (${lineno}:${colno})`);
    };

    window.onunhandledrejection = function(event) {
      showError(event.reason ? event.reason.toString() : 'Unhandled rejection');
    };

    window.__forceError = function() {
      setTimeout(() => {
        throw new Error('強制エラー発生');
      }, 0);
      Promise.reject(new Error('強制エラー発生'));
    };

    document.getElementById('error-dismiss').addEventListener('click', () => {
      document.getElementById('error-banner').classList.add('hidden');
    });

    function navigate(hash) {
      if (window.location.hash === hash) {
        handleNavigation(hash);
      } else {
        window.location.hash = hash;
      }
    }

    function handleNavigation(hash) {
      const valid = ['#/dashboard', '#/today', '#/exercise', '#/set', '#/history', '#/settings'];
      const next = valid.includes(hash) ? hash : '#/dashboard';
      uiState.route = next;
      
      // bodyの背景色をルートに応じて変更
      const bgColors = {
        '#/dashboard': 'bg-neutral-50',
        '#/today': 'bg-violet-50',
        '#/exercise': 'bg-orange-50',
        '#/set': 'bg-orange-50',
        '#/history': 'bg-amber-50',
        '#/settings': 'bg-sky-50'
      };
      
      const body = document.body;
      // 既存の背景色クラスを削除
      Object.values(bgColors).forEach(cls => body.classList.remove(cls));
      // 新しい背景色クラスを追加
      body.classList.add(bgColors[next]);
      
      document.querySelectorAll('.route-view').forEach(section => {
        section.classList.toggle('hidden', section.getAttribute('data-route') !== next);
      });
      render();
    }

    window.addEventListener('hashchange', () => handleNavigation(window.location.hash));

    function render() {
      if (uiState.route === '#/dashboard') renderDashboard();
      if (uiState.route === '#/today') renderToday();
      if (uiState.route === '#/exercise') renderExercise();
      if (uiState.route === '#/set') renderSet();
      if (uiState.route === '#/history') renderHistory();
      if (uiState.route === '#/settings') renderSettings();
    }

    function renderDashboard() {
      const container = document.querySelector('[data-route="#/dashboard"]');
      container.innerHTML = '';

      // ナビゲーションボタン
      const navContainer = document.createElement('div');
      navContainer.className = 'space-y-3';
      
      // 今日のトレーニングボタン（全幅）
      const todayButton = document.createElement('button');
      todayButton.type = 'button';
      todayButton.className = 'ios-card bg-white w-full px-6 py-4 text-base font-light transition active:scale-[0.99] min-h-[44px] sumi-text hover:gold-accent border border-neutral-100';
      todayButton.innerHTML = `
        <div class="flex flex-col items-center gap-2">
          <span class="text-2xl">📝</span>
          <span>今日のトレーニング</span>
        </div>
      `;
      todayButton.addEventListener('click', () => navigate('#/today'));
      navContainer.appendChild(todayButton);
      
      // 履歴と設定ボタン（半分ずつ）
      const bottomRow = document.createElement('div');
      bottomRow.className = 'grid grid-cols-2 gap-3';
      
      const historyButton = document.createElement('button');
      historyButton.type = 'button';
      historyButton.className = 'ios-card bg-white w-full px-6 py-4 text-base font-light transition active:scale-[0.99] min-h-[44px] sumi-text hover:gold-accent border border-neutral-100';
      historyButton.innerHTML = `
        <div class="flex flex-col items-center gap-2">
          <span class="text-2xl">📖</span>
          <span>履歴</span>
        </div>
      `;
      historyButton.addEventListener('click', () => navigate('#/history'));
      bottomRow.appendChild(historyButton);
      
      const settingsButton = document.createElement('button');
      settingsButton.type = 'button';
      settingsButton.className = 'ios-card bg-white w-full px-6 py-4 text-base font-light transition active:scale-[0.99] min-h-[44px] sumi-text hover:gold-accent border border-neutral-100';
      settingsButton.innerHTML = `
        <div class="flex flex-col items-center gap-2">
          <span class="text-2xl">⚙️</span>
          <span>設定</span>
        </div>
      `;
      settingsButton.addEventListener('click', () => navigate('#/settings'));
      bottomRow.appendChild(settingsButton);
      
      navContainer.appendChild(bottomRow);
      container.appendChild(navContainer);

      // 統計情報カード
      const stats = computeDashboardStats();
      const statsCard = document.createElement('section');
      statsCard.className = 'section-card bg-white p-4 space-y-3';
      statsCard.innerHTML = `
        <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">統計情報</h2>
        <div class="grid grid-cols-3 gap-3 text-center">
          <div class="section-card gold-accent py-4 px-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs sumi-text-light font-light mb-1">今週</p>
            <p class="text-3xl font-light sumi-text">${stats.thisWeek}</p>
            <p class="text-xs sumi-text-light font-light mt-1">回</p>
          </div>
          <div class="section-card bg-neutral-50 py-4 px-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs sumi-text-light font-light mb-1">総日数</p>
            <p class="text-3xl font-light sumi-text">${stats.totalDays}</p>
            <p class="text-xs sumi-text-light font-light mt-1">日</p>
          </div>
          <div class="section-card bg-neutral-50 py-4 px-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs sumi-text-light font-light mb-1">最終日</p>
            <p class="text-lg font-light sumi-text">${stats.lastDate}</p>
          </div>
        </div>
      `;
      container.appendChild(statsCard);

      // 最近のトレーニング概要
      if (state.history.length > 0) {
        const recentSection = document.createElement('section');
        recentSection.className = 'section-card bg-white p-4 space-y-3';
        
        const header = document.createElement('div');
        header.className = 'flex items-center justify-between';
        header.innerHTML = `
          <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.05em;">最近のトレーニング</h2>
          <button type="button" class="text-sm sumi-text-light hover:sumi-text transition font-light" id="view-all-history">すべて見る →</button>
        `;
        recentSection.appendChild(header);
        
        const recentWorkouts = state.history.slice(0, 3);
        recentWorkouts.forEach((workout, index) => {
          const workoutCard = createRecentWorkoutCard(workout);
          recentSection.appendChild(workoutCard);
          if (index < recentWorkouts.length - 1) {
            const divider = document.createElement('div');
            divider.className = 'border-t border-neutral-100';
            recentSection.appendChild(divider);
          }
        });
        
        container.appendChild(recentSection);
        
        document.getElementById('view-all-history')?.addEventListener('click', () => navigate('#/history'));
      } else {
        // 履歴がない場合のメッセージ
        const emptyCard = document.createElement('section');
        emptyCard.className = 'section-card bg-white p-6 text-center';
        emptyCard.innerHTML = `
          <p class="text-base sumi-text-light font-light mb-4">まだトレーニング履歴がありません</p>
          <button type="button" class="ios-card gold-accent px-6 py-3 text-base font-light sumi-text transition active:scale-[0.99] min-h-[44px]" id="start-first-workout">最初のトレーニングを始める</button>
        `;
        container.appendChild(emptyCard);
        
        document.getElementById('start-first-workout')?.addEventListener('click', () => navigate('#/today'));
      }
    }

    function computeDashboardStats() {
      // 今週のトレーニング回数を計算
      const now = new Date();
      const startOfWeek = new Date(now);
      startOfWeek.setDate(now.getDate() - now.getDay()); // 日曜日を週の始まりとする
      startOfWeek.setHours(0, 0, 0, 0);
      
      const thisWeekCount = state.history.filter(workout => {
        const workoutDate = new Date(workout.date);
        return workoutDate >= startOfWeek;
      }).length;
      
      // 総トレーニング日数
      const totalDays = state.history.length;
      
      // 最後のトレーニング日付
      let lastDate = '-';
      if (state.history.length > 0) {
        const lastWorkout = state.history[0];
        const date = new Date(lastWorkout.date);
        lastDate = `${date.getMonth() + 1}/${date.getDate()}`;
      }
      
      return {
        thisWeek: thisWeekCount,
        totalDays,
        lastDate
      };
    }

    function createRecentWorkoutCard(workout) {
      const card = document.createElement('div');
      card.className = 'py-3 space-y-2';
      
      const date = new Date(workout.date);
      const dateStr = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
      
      // 種目数とセット数を計算
      const exerciseCount = workout.items.length;
      const totalSets = workout.items.reduce((sum, item) => sum + item.sets.length, 0);
      
      // 部位を集計
      const parts = [...new Set(workout.items.map(item => {
        const part = state.master.parts.find(p => p.id === item.part);
        return part ? part.label : item.part;
      }))].join('、');
      
      card.innerHTML = `
        <div class="flex items-center justify-between">
          <p class="text-sm font-light sumi-text">${dateStr}</p>
          <p class="text-xs sumi-text-light font-light">${exerciseCount}種目 · ${totalSets}セット</p>
        </div>
        <p class="text-xs sumi-text-light font-light">${parts}</p>
      `;
      
      return card;
    }

    function computeTodayStats() {
      const singles = state.day.items
        .filter(item => item.mode === 'single')
        .flatMap(item => item.sets)
        .filter(set => !set.warmup)
        .length;
      const roundMap = new Map();
      state.day.items
        .filter(item => item.mode === 'superset' && item.groupId)
        .forEach(item => {
          if (!roundMap.has(item.groupId)) roundMap.set(item.groupId, new Map());
          const groupRounds = roundMap.get(item.groupId);
          item.sets.forEach(set => {
            if (set.round === null || set.round === undefined) return;
            if (!groupRounds.has(set.round)) groupRounds.set(set.round, { hasWorking: false });
            if (!set.warmup) {
              groupRounds.get(set.round).hasWorking = true;
            }
          });
        });
      let supersetRounds = 0;
      roundMap.forEach(group => {
        group.forEach(entry => {
          if (entry.hasWorking) supersetRounds += 1;
        });
      });
      return {
        soloSets: singles,
        supersetRounds,
        workSets: singles + supersetRounds
      };
    }

    function renderToday() {
      const container = document.querySelector('[data-route="#/today"]');
      container.innerHTML = '';

      // ヘッダー（タイトルとホームボタン）
      const header = document.createElement('div');
      header.className = 'flex items-center justify-between mb-3';
      const title = document.createElement('h1');
      title.className = 'text-lg font-light sumi-text';
      const isEditing = uiState.editingHistoryIndex !== null;
      title.textContent = isEditing ? '履歴を編集' : '今日のトレーニング';
      header.appendChild(title);
      const homeButton = document.createElement('button');
      homeButton.type = 'button';
      homeButton.className = 'flex items-center gap-1 text-sm font-light sumi-text-light hover:sumi-text transition min-h-[44px] px-3';
      homeButton.innerHTML = '← ホーム';
      homeButton.addEventListener('click', () => navigate('#/dashboard'));
      header.appendChild(homeButton);
      container.appendChild(header);

      const statsSection = document.createElement('section');
      statsSection.className = 'section-card bg-white p-4 space-y-2';
      const summary = computeTodayStats();
      statsSection.innerHTML = `
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-base font-light sumi-text" style="letter-spacing: 0.03em;">今日の概要</h2>
          <span class="text-xs font-light sumi-text-light">ウォームアップ除外</span>
        </div>
        <div class="grid grid-cols-3 gap-2 text-center">
          <div class="ios-card py-3 min-h-[44px] flex flex-col justify-center border" style="background-color: rgba(245, 237, 214, 0.15); border-color: rgba(212, 175, 55, 0.2); color: var(--color-gold);">
            <p class="text-xs font-light">作業セット</p>
            <p class="text-2xl font-light">${summary.workSets}</p>
          </div>
          <div class="ios-card py-3 min-h-[44px] flex flex-col justify-center border" style="background-color: rgba(245, 237, 214, 0.15); border-color: rgba(212, 175, 55, 0.2); color: var(--color-gold);">
            <p class="text-xs font-light">SSラウンド</p>
            <p class="text-2xl font-light">${summary.supersetRounds}</p>
          </div>
          <div class="ios-card py-3 min-h-[44px] flex flex-col justify-center border" style="background-color: rgba(245, 237, 214, 0.15); border-color: rgba(212, 175, 55, 0.2); color: var(--color-gold);">
            <p class="text-xs font-light">単独セット</p>
            <p class="text-2xl font-light">${summary.soloSets}</p>
          </div>
        </div>
      `;
      container.appendChild(statsSection);

      // メモ入力欄
      const memoSection = document.createElement('div');
      memoSection.className = 'section-card bg-white p-4 space-y-2';
      const memoLabel = document.createElement('label');
      memoLabel.className = 'text-xs font-light sumi-text-light';
      memoLabel.textContent = 'トレーニングメモ';
      const memoTextarea = document.createElement('textarea');
      memoTextarea.className = 'w-full p-3 text-sm sumi-text font-light border rounded-lg focus:outline-none focus:ring-2 focus:ring-gold/30 transition';
      memoTextarea.style.cssText = 'border-color: rgba(115, 115, 115, 0.2); background-color: rgba(245, 237, 214, 0.05); min-height: 80px; resize: vertical;';
      memoTextarea.placeholder = '今日のトレーニングのメモを記録...';
      memoTextarea.value = state.day.memo || '';
      memoTextarea.addEventListener('input', (e) => {
        state.day.memo = e.target.value;
      });
      memoSection.appendChild(memoLabel);
      memoSection.appendChild(memoTextarea);
      container.appendChild(memoSection);

      const actionRow = document.createElement('div');
      actionRow.className = 'flex items-center gap-3';
      const addButton = document.createElement('button');
      addButton.type = 'button';
      addButton.className = 'ios-card px-6 py-3 font-light text-base min-h-[44px] border transition';
      addButton.style.cssText = 'background-color: var(--color-gold); color: white; border-color: var(--color-gold-dark); letter-spacing: 0.05em; flex: 2;';
      addButton.textContent = '＋ 種目追加';
      addButton.addEventListener('click', () => {
        uiState.exerciseForm = createExerciseFormState();
        navigate('#/exercise');
      });
      actionRow.appendChild(addButton);
      
      const completeButton = document.createElement('button');
      completeButton.type = 'button';
      completeButton.className = 'ios-card px-6 py-3 font-light text-base min-h-[44px] border transition';
      completeButton.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em; flex: 1;';
      completeButton.textContent = isEditing ? '保存' : '完了';
      completeButton.addEventListener('click', () => {
        const message = isEditing ? '変更を保存しますか？' : '今日のトレーニングを完了しますか？';
        if (confirm(message)) {
          completeWorkout();
        }
      });
      actionRow.appendChild(completeButton);
      container.appendChild(actionRow);

      const list = document.createElement('div');
      list.className = 'space-y-3';
      const sortedItems = [...state.day.items].sort((a, b) => a.order - b.order);
      const processedGroups = new Set();
      sortedItems.forEach(item => {
        if (item.mode === 'superset') {
          if (!item.groupId || processedGroups.has(item.groupId)) return;
          const groupItems = sortedItems.filter(candidate => candidate.groupId === item.groupId);
          processedGroups.add(item.groupId);
          list.appendChild(buildSupersetCard(groupItems));
        } else {
          list.appendChild(buildSingleCard(item));
        }
      });
      container.appendChild(list);
    }

    function buildSingleCard(item) {
      const card = document.createElement('article');
      card.className = 'section-card bg-white p-4 space-y-2';
      const partLabel = state.master.parts.find(p => p.id === item.part)?.label ?? '';
      
      // ヘッダー：種目名と部位
      const header = document.createElement('div');
      header.className = 'space-y-1';
      header.innerHTML = `
        <p class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${item.exercise}</p>
        <p class="text-xs font-light sumi-text-light">${partLabel}</p>
      `;
      card.appendChild(header);
      
      // 器具・角度・ポジション
      const details = document.createElement('div');
      details.className = 'text-xs font-light sumi-text-light';
      details.textContent = [item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ');
      card.appendChild(details);
      if (item.attachment && item.attachment !== '-') {
        const att = document.createElement('p');
        att.className = 'text-[11px] font-light sumi-text-light';
        att.textContent = `アタッチメント: ${item.attachment}`;
        card.appendChild(att);
      }

      const badgeArea = document.createElement('div');
      badgeArea.className = 'flex flex-col gap-2';
      groupSetsForDisplay(item.sets).forEach(group => {
        const row = document.createElement('div');
        row.className = 'flex flex-col gap-1';
        const badgeRow = document.createElement('div');
        badgeRow.className = 'flex items-start gap-2';
        badgeRow.appendChild(createSetBadge(group.base, item));
        if (group.drops.length > 0) {
          const dropList = document.createElement('div');
          dropList.className = 'pl-6 flex flex-wrap gap-2';
          group.drops.forEach(drop => dropList.appendChild(createSetBadge(drop, item, true)));
          badgeRow.appendChild(dropList);
        }
        row.appendChild(badgeRow);
        if (group.base.memo) {
          const memoDiv = document.createElement('div');
          memoDiv.className = 'pl-1 text-[10px] font-light sumi-text-light';
          memoDiv.textContent = `メモ: ${group.base.memo}`;
          row.appendChild(memoDiv);
        }
        badgeArea.appendChild(row);
      });
      card.appendChild(badgeArea);

      const controls = document.createElement('div');
      controls.className = 'flex justify-end';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'px-4 py-2 rounded-full text-sm font-light min-h-[44px] border transition';
      editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
      editBtn.textContent = '編集';
      editBtn.addEventListener('click', () => {
        uiState.currentItemId = item.id;
        prepareSetEditor(item.id);
        navigate('#/set');
      });
      controls.appendChild(editBtn);
      card.appendChild(controls);
      return card;
    }

    function buildSupersetCard(groupItems) {
      const sorted = [...groupItems].sort((a, b) => a.order - b.order);
      const labels = ['A', 'B', 'C'];
      const title = `(SS) ${sorted.map(item => item.exercise).join(' + ')}`;
      const card = document.createElement('article');
      card.className = 'section-card bg-white p-4 space-y-2';
      
      // ヘッダー：種目名と部位
      const header = document.createElement('div');
      header.className = 'space-y-1';
      header.innerHTML = `
        <p class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${title}</p>
        <p class="text-xs font-light sumi-text-light">${sorted.map((item, index) => `${labels[index]}. ${state.master.parts.find(p => p.id === item.part)?.label ?? ''}`).join(' / ')}</p>
      `;
      card.appendChild(header);
      
      // 器具・角度・ポジション
      const details = document.createElement('div');
      details.className = 'text-xs font-light sumi-text-light';
      details.textContent = sorted.map(item => [item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ')).join(' ｜ ');
      card.appendChild(details);

      const rounds = buildSupersetRounds(sorted);
      if (rounds.length > 0) {
        const roundList = document.createElement('div');
        roundList.className = 'flex flex-col gap-2';
        rounds.forEach(round => {
          const row = document.createElement('div');
          row.className = 'flex flex-col gap-1';
          const badgeRow = document.createElement('div');
          badgeRow.className = 'flex flex-wrap gap-2 items-start';
          round.entries.forEach(entry => badgeRow.appendChild(entry));
          row.appendChild(badgeRow);
          if (round.drops.length > 0) {
            const dropRow = document.createElement('div');
            dropRow.className = 'pl-6 flex flex-wrap gap-2';
            round.drops.forEach(drop => dropRow.appendChild(drop));
            row.appendChild(dropRow);
          }
          roundList.appendChild(row);
        });
        card.appendChild(roundList);
      }

      const soloArea = document.createElement('div');
      const soloChips = [];
      sorted.forEach((item, index) => {
        const solos = groupSetsForDisplay(item.sets.filter(set => set.round == null));
        solos.forEach(group => {
          const row = document.createElement('div');
          row.className = 'flex items-start gap-2';
          const chip = createSetBadge(group.base, item);
          chip.textContent = `${labels[index]}: ${chip.textContent}`;
          row.appendChild(chip);
          if (group.drops.length > 0) {
            const dropList = document.createElement('div');
            dropList.className = 'pl-6 flex flex-wrap gap-2';
            group.drops.forEach(drop => dropList.appendChild(createSetBadge(drop, item, true)));
            row.appendChild(dropList);
          }
          soloChips.push(row);
        });
      });
      if (soloChips.length > 0) {
        const soloArea = document.createElement('div');
        soloArea.className = 'space-y-2 pt-2 border-t border-neutral-100';
        const soloList = document.createElement('div');
        soloList.className = 'space-y-2';
        soloChips.forEach(row => soloList.appendChild(row));
        soloArea.appendChild(soloList);
        card.appendChild(soloArea);
      }

      const controls = document.createElement('div');
      controls.className = 'flex justify-end gap-3 pt-1';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'px-4 py-2 rounded-full text-sm font-light min-h-[44px] border transition';
      editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
      editBtn.textContent = '編集';
      editBtn.addEventListener('click', () => {
        uiState.currentItemId = sorted[0].id;
        prepareSetEditor(sorted[0].id);
        navigate('#/set');
      });
      controls.appendChild(editBtn);
      card.appendChild(controls);
      return card;
    }

    function buildSupersetRounds(groupItems) {
      const map = new Map();
      const labels = ['A', 'B', 'C'];
      groupItems.forEach((item, index) => {
        let currentBase = null;
        item.sets
          .filter(set => set.round !== null && set.round !== undefined)
          .sort((a, b) => a.ts - b.ts)
          .forEach(set => {
            if (!map.has(set.round)) {
              map.set(set.round, { entries: new Map(), drops: [] });
            }
            const slot = map.get(set.round);
            if (!set.drop) {
              currentBase = { item, set };
              slot.entries.set(labels[index], { item, set, drops: [] });
            } else if (currentBase && slot.entries.has(labels[index])) {
              slot.entries.get(labels[index]).drops.push({ item, set });
            } else {
              slot.drops.push(createSetBadge(set, item, true));
            }
          });
      });
      const rows = [];
      [...map.keys()].sort((a, b) => a - b).forEach(round => {
        const entry = map.get(round);
        const displayEntries = [];
        const dropBadges = [...entry.drops];
        groupItems.forEach((item, index) => {
          const label = labels[index];
          const data = entry.entries.get(label);
          if (data) {
            const chip = createSetBadge(data.set, data.item);
            chip.textContent = `${label}: ${chip.textContent}`;
            displayEntries.push(chip);
            data.drops.forEach(drop => {
              dropBadges.push(createSetBadge(drop.set, drop.item, true));
            });
          }
        });
        if (displayEntries.length > 0) {
          rows.push({ entries: displayEntries, drops: dropBadges });
        }
      });
      return rows;
    }

    function groupSetsForDisplay(sets) {
      const rows = [];
      let current = null;
      sets.forEach(set => {
        if (!set.drop) {
          current = { base: set, drops: [] };
          rows.push(current);
        } else if (current) {
          current.drops.push(set);
        } else {
          rows.push({ base: set, drops: [] });
        }
      });
      return rows;
    }

    function createSetBadge(set, item, isDrop = false) {
      const badge = document.createElement('span');
      const baseClasses = 'inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold min-h-[32px] truncate';
      const color = set.warmup ? 'bg-slate-200 text-slate-600' : 'bg-orange-100 text-orange-700';
      badge.className = `${baseClasses} ${isDrop ? 'border border-orange-200 bg-orange-50 text-orange-600' : color}`;
      badge.textContent = formatSetValue(set, item.timed);
      return badge;
    }

    function formatSetValue(set, timed) {
      if (timed) {
        return `${set.seconds ?? '-'}秒`;
      }
      const weight = set.weight != null ? `${set.weight}kg` : '-kg';
      const reps = set.repsU != null ? `${set.repsU}` : '-';
      const assist = set.repsA != null && set.repsA > 0 ? ` +${set.repsA}` : '';
      return `${weight}×${reps}${assist}`;
    }

    function renderExercise() {
      const container = document.querySelector('[data-route="#/exercise"]');
      container.innerHTML = '';

      const form = document.createElement('form');
      form.className = 'section-card bg-white p-6 space-y-6';
      form.innerHTML = `
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-light sumi-text" style="letter-spacing: 0.05em;">種目入力</h2>
          <button type="button" id="exerciseBack" class="text-sm font-light px-3 py-2 min-h-[44px] transition" style="color: var(--color-gold);">← 戻る</button>
        </div>
        <div class="flex items-center justify-between gap-3 rounded-2xl px-4 py-3 text-sm gold-accent border" style="border-color: rgba(212, 175, 55, 0.15);">
          <div class="flex items-center gap-3 sumi-text-mid">
            <input type="checkbox" id="supersetToggle" class="w-5 h-5 rounded" style="color: var(--color-gold);" ${uiState.exerciseForm.superset ? 'checked' : ''}>
            <label for="supersetToggle" class="font-light">スーパーセットにする</label>
          </div>
          <button type="button" id="resetForm" class="text-xs sumi-text-light hover:sumi-text font-light px-2 py-1 transition">リセット</button>
        </div>
        <div id="exercisePreview" class="hidden rounded-xl px-4 py-3 text-sm border" style="background-color: rgba(245, 237, 214, 0.3); border-color: rgba(212, 175, 55, 0.2);">
          <div class="flex items-start gap-2">
            <svg class="w-5 h-5 mt-0.5 flex-shrink-0" style="color: var(--color-gold);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <div class="flex-1">
              <div class="font-light sumi-text mb-1" style="letter-spacing: 0.02em;">入力中の種目</div>
              <div id="exercisePreviewText" class="sumi-text-mid font-light"></div>
            </div>
          </div>
        </div>
        <div id="exerciseCards" class="flex flex-col gap-4"></div>
        <div class="flex justify-between items-center">
          <button type="submit" class="ios-card text-white px-6 py-3 font-light min-h-[44px] transition" style="background-color: var(--color-gold); letter-spacing: 0.05em;">決定</button>
        </div>
      `;
      container.appendChild(form);

      const cardsContainer = form.querySelector('#exerciseCards');
      renderExerciseCards(cardsContainer);

      // リセットボタンのイベント
      form.querySelector('#resetForm').addEventListener('click', () => {
        clearLastExerciseSettings();
        uiState.exerciseForm = {
          superset: false,
          cards: [createExerciseCardState('A')]
        };
        renderExercise();
      });
      
      // プレビュー更新関数
      function updateExercisePreview() {
        const preview = form.querySelector('#exercisePreview');
        const previewText = form.querySelector('#exercisePreviewText');
        const cards = uiState.exerciseForm.cards;
        
        if (cards.length === 0) {
          preview.classList.add('hidden');
          return;
        }
        
        const descriptions = cards.map((card, index) => {
          const partLabel = state.master.parts.find(p => p.id === card.part)?.label || card.part;
          const details = [card.exercise, card.gear !== '-' ? card.gear : null, card.attachment !== '-' ? card.attachment : null, card.angle !== '-' ? card.angle : null, card.position !== '-' ? card.position : null].filter(Boolean).join(' / ');
          const prefix = uiState.exerciseForm.superset ? `${['A', 'B', 'C'][index]}: ` : '';
          return `${prefix}${partLabel} - ${details}`;
        });
        
        previewText.innerHTML = descriptions.join('<br>');
        preview.classList.remove('hidden');
        
        // LocalStorageに保存
        saveLastExerciseSettings(uiState.exerciseForm);
      }

      form.addEventListener('change', event => {
        if (event.target.id === 'supersetToggle') {
          uiState.exerciseForm.superset = event.target.checked;
          if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length < 2) {
            uiState.exerciseForm.cards = [createExerciseCardState('A'), createExerciseCardState('B')];
          }
          if (!uiState.exerciseForm.superset) {
            uiState.exerciseForm.cards = [createExerciseCardState('A')];
          }
          renderExercise();
        }
        updateExercisePreview();
      });
      
      // 初回プレビュー表示
      updateExercisePreview();

      form.addEventListener('submit', event => {
        event.preventDefault();
        const newItems = buildItemsFromExerciseForm();
        const baseOrder = Math.max(0, ...state.day.items.map(item => item.order)) + 1;
        newItems.forEach((item, index) => {
          item.order = item.mode === 'superset' ? baseOrder + index * 0.01 : baseOrder;
          state.day.items.push(item);
        });
        state.day.items.sort((a, b) => a.order - b.order);
        const firstId = newItems[0]?.id;
        if (firstId) {
          uiState.currentItemId = firstId;
          prepareSetEditor(firstId, true);
          navigate('#/set');
        } else {
          navigate('#/today');
        }
      });

      form.querySelector('#exerciseBack').addEventListener('click', () => navigate('#/today'));
    }

    function renderExerciseCards(container) {
      container.innerHTML = '';
      uiState.exerciseForm.cards.forEach((card, index) => {
        const cardEl = document.createElement('section');
        cardEl.className = 'bg-white rounded-2xl p-4 space-y-3 border border-neutral-200/40 shadow-sm';
        const label = uiState.exerciseForm.superset ? ['A', 'B', 'C'][index] : '';
        const title = uiState.exerciseForm.superset ? `${label} 種目` : '種目設定';
        cardEl.innerHTML = `
          <div class="flex items-center justify-between mb-1">
            <h3 class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${title}</h3>
            ${uiState.exerciseForm.superset && uiState.exerciseForm.cards.length > 2 && index === uiState.exerciseForm.cards.length - 1
              ? '<button type="button" class="text-xs sumi-text-light hover:sumi-text font-light transition" data-remove="true">削除</button>'
              : ''}
          </div>
          
          <!-- 基本情報 -->
          <div class="space-y-2 pb-2 border-b border-neutral-200/30">
            <div class="flex items-center gap-1.5">
              <div class="w-0.5 h-3 rounded-full" style="background-color: var(--color-gold);"></div>
              <h4 class="text-xs font-light sumi-text-mid" style="letter-spacing: 0.05em;">基本情報</h4>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid flex items-center gap-0.5">
                  部位<span style="color: var(--color-gold);">*</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="part"></select>
              </label>
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid flex items-center gap-0.5">
                  種目<span style="color: var(--color-gold);">*</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="exercise"></select>
              </label>
            </div>
          </div>
          
          <!-- 器具設定 -->
          <div class="space-y-2 py-2 border-b border-neutral-200/30">
            <div class="flex items-center gap-1.5">
              <div class="w-0.5 h-3 rounded-full" style="background-color: var(--color-gold-light);"></div>
              <h4 class="text-xs font-light sumi-text-mid" style="letter-spacing: 0.05em;">器具</h4>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid">
                  器具 <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="gear"></select>
              </label>
              <label class="flex flex-col gap-1" data-attachment-field>
                <span class="text-xs font-light sumi-text-mid">
                  アタッチメント <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="attachment"></select>
              </label>
            </div>
            <div class="text-[10px] sumi-text-light pl-0.5 font-light" data-attachment-hint>ケーブル/マシン時に設定</div>
          </div>
          
          <!-- 詳細設定 -->
          <div class="space-y-2 pt-2">
            <div class="flex items-center gap-1.5">
              <div class="w-0.5 h-3 rounded-full" style="background-color: var(--color-gold-pale);"></div>
              <h4 class="text-xs font-light sumi-text-mid" style="letter-spacing: 0.05em;">詳細</h4>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid">
                  角度 <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="angle"></select>
              </label>
              <label class="flex flex-col gap-1">
                <span class="text-xs font-light sumi-text-mid">
                  ポジション <span class="sumi-text-light text-[10px]">(任意)</span>
                </span>
                <select class="w-full rounded-lg border border-neutral-200 px-2 py-1.5 text-sm min-h-[40px] sumi-text bg-white transition" style="border-color: rgba(115, 115, 115, 0.2);" data-field="position"></select>
              </label>
            </div>
            <div class="flex flex-wrap gap-2 text-xs pt-1">
              <label class="flex items-center gap-1.5 rounded-lg px-3 py-1.5 border cursor-pointer transition" style="border-color: rgba(115, 115, 115, 0.15); background-color: rgba(245, 237, 214, 0.1);">
                <input type="checkbox" class="w-3.5 h-3.5 rounded focus:ring-1" style="color: var(--color-gold);" data-field="timed" ${card.timed ? 'checked' : ''}>
                <span class="font-light sumi-text">秒数記録</span>
              </label>
              <label class="flex items-center gap-1.5 rounded-lg px-3 py-1.5 border cursor-pointer transition" style="border-color: rgba(115, 115, 115, 0.15); background-color: rgba(245, 237, 214, 0.1);">
                <input type="checkbox" class="w-3.5 h-3.5 rounded focus:ring-1" style="color: var(--color-gold);" data-field="oneHand" ${card.oneHand ? 'checked' : ''}>
                <span class="font-light sumi-text">ワンハンド</span>
              </label>
              <label class="flex items-center gap-1.5 rounded-lg px-3 py-1.5 border cursor-pointer transition" style="border-color: rgba(115, 115, 115, 0.15); background-color: rgba(245, 237, 214, 0.1);">
                <input type="checkbox" class="w-3.5 h-3.5 rounded focus:ring-1" style="color: var(--color-gold);" data-field="dropset" ${card.dropset ? 'checked' : ''}>
                <span class="font-light sumi-text">ドロップセット</span>
              </label>
            </div>
          </div>
        `;
        container.appendChild(cardEl);

        const partSelect = cardEl.querySelector('[data-field="part"]');
        const exerciseSelect = cardEl.querySelector('[data-field="exercise"]');
        const selects = [
          { element: partSelect, field: 'part', options: state.master.parts.map(p => ({ value: p.id, label: p.label })) },
          { element: cardEl.querySelector('[data-field="gear"]'), field: 'gear', options: sortForDisplay(state.master.gear).map(value => ({ value, label: value })) },
          { element: cardEl.querySelector('[data-field="attachment"]'), field: 'attachment', options: sortForDisplay(state.master.attachments).map(value => ({ value, label: value })) },
          { element: cardEl.querySelector('[data-field="angle"]'), field: 'angle', options: sortForDisplay(state.master.angles).map(value => ({ value, label: value })) },
          { element: cardEl.querySelector('[data-field="position"]'), field: 'position', options: sortForDisplay(state.master.positions).map(value => ({ value, label: value })) }
        ];
        populateSelect(partSelect, selects[0].options, card.part);
        updateExerciseOptions(exerciseSelect, card);
        selects.slice(1).forEach(select => populateSelect(select.element, select.options, card[select.field]));

        // アタッチメントフィールドの文脈依存表示
        const gearSelect = cardEl.querySelector('[data-field="gear"]');
        const attachmentField = cardEl.querySelector('[data-attachment-field]');
        const attachmentHint = cardEl.querySelector('[data-attachment-hint]');
        
        function updateAttachmentHighlight() {
          const gear = gearSelect.value;
          const needsAttachment = gear === 'ケーブル' || gear === 'マシン';
          if (needsAttachment) {
            attachmentField.classList.add('ring-2', 'ring-amber-200', 'bg-amber-50/30');
            attachmentHint.classList.remove('text-slate-400');
            attachmentHint.classList.add('text-amber-600', 'font-medium');
          } else {
            attachmentField.classList.remove('ring-2', 'ring-amber-200', 'bg-amber-50/30');
            attachmentHint.classList.remove('text-amber-600', 'font-medium');
            attachmentHint.classList.add('text-slate-400');
          }
        }
        
        updateAttachmentHighlight();

        cardEl.querySelectorAll('select, input[type="checkbox"]').forEach(field => {
          field.addEventListener('change', event => {
            const target = event.target;
            const fieldName = target.getAttribute('data-field');
            if (!fieldName) return;
            if (fieldName === 'part') {
              card.part = target.value;
              updateExerciseOptions(exerciseSelect, card);
            } else if (fieldName === 'exercise') {
              card.exercise = target.value;
            } else if (fieldName === 'gear') {
              card.gear = target.value;
              updateAttachmentHighlight();
            } else if (fieldName === 'timed' || fieldName === 'oneHand' || fieldName === 'dropset') {
              card[fieldName] = target.checked;
            } else {
              card[fieldName] = target.value;
            }
          });
        });

        if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length > 2 && index === uiState.exerciseForm.cards.length - 1) {
          cardEl.querySelector('[data-remove="true"]').addEventListener('click', () => {
            uiState.exerciseForm.cards.splice(index, 1);
            renderExercise();
          });
        }
      });

      if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length < 3) {
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'w-full text-sm text-indigo-500 font-semibold px-4 py-3 bg-white rounded-2xl border border-dashed border-indigo-200 min-h-[44px]';
        addBtn.textContent = '＋ カード追加';
        addBtn.addEventListener('click', () => {
          const label = ['A', 'B', 'C'][uiState.exerciseForm.cards.length] || 'C';
          uiState.exerciseForm.cards.push(createExerciseCardState(label));
          renderExercise();
        });
        container.appendChild(addBtn);
      }
    }

    function populateSelect(select, options, selected) {
      select.innerHTML = '';
      options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        if (option.value === selected) opt.selected = true;
        select.appendChild(opt);
      });
    }

    function updateExerciseOptions(select, card) {
      const exercises = sortForDisplay(state.master.exercises[card.part] || []);
      const actual = card.exercise && exercises.includes(card.exercise) ? card.exercise : exercises[0] || '';
      select.innerHTML = '';
      exercises.forEach(value => {
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = value;
        if (value === actual) opt.selected = true;
        select.appendChild(opt);
      });
      card.exercise = actual;
    }

    function buildItemsFromExerciseForm() {
      const idBase = Date.now();
      if (!uiState.exerciseForm.superset) {
        const card = uiState.exerciseForm.cards[0];
        return [buildItemFromCard(card, `${idBase}`)];
      }
      const groupId = createGroupId();
      return uiState.exerciseForm.cards.map((card, index) => buildItemFromCard(card, `${idBase}-${index}`, groupId));
    }

    function buildItemFromCard(card, keySeed, groupId = null) {
      return {
        id: createId('item'),
        order: state.day.items.length + 1,
        mode: groupId ? 'superset' : 'single',
        groupId,
        part: card.part,
        exercise: card.exercise,
        gear: card.gear,
        attachment: card.attachment,
        angle: card.angle,
        position: card.position,
        timed: card.timed,
        oneHand: card.oneHand,
        dropset: card.dropset,
        sets: []
      };
    }

    function prepareSetEditor(itemId, isNew = false) {
      const target = state.day.items.find(item => item.id === itemId);
      if (!target) return;
      let items = [];
      if (target.mode === 'superset' && target.groupId) {
        items = state.day.items.filter(item => item.groupId === target.groupId).sort((a, b) => a.order - b.order);
      } else {
        items = [target];
      }
      const editorItems = items.map((item, index) => ({
        itemId: item.id,
        label: ['A', 'B', 'C'][index] || 'A',
        timed: item.timed,
        dropset: item.dropset,
        mode: item.mode,
        rows: buildRowsFromSets(item.sets, item.timed)
      }));
      const maxRound = Math.max(-1, ...items.flatMap(item => item.sets.filter(set => set.round != null).map(set => set.round)));
      uiState.setEditor = {
        isSuperset: target.mode === 'superset',
        activeIndex: items.findIndex(item => item.id === itemId) || 0,
        items: editorItems,
        cycleBuffers: editorItems.map(item => createBuffer(item.timed)),
        nextRound: maxRound + 1,
        isNew
      };
    }

    function buildRowsFromSets(sets, timed) {
      const rows = [];
      let current = null;
      sets.sort((a, b) => a.ts - b.ts).forEach(set => {
        if (!set.drop) {
          current = createRowFromSet(set);
          rows.push(current);
        } else if (current) {
          current.drops.push(createDropFromSet(set));
        } else {
          const orphan = createRowFromSet(set);
          rows.push(orphan);
        }
      });
      if (rows.length === 0) {
        rows.push(createBlankRow(timed));
      }
      return rows;
    }

    function createRowFromSet(set) {
      return {
        id: set.id || createId('row'),
        weight: set.weight ?? '',
        repsU: set.repsU ?? '',
        repsA: set.repsA ?? '',
        seconds: set.seconds ?? '',
        warmup: !!set.warmup,
        round: set.round ?? null,
        drops: []
      };
    }

    function createDropFromSet(set) {
      return {
        id: set.id || createId('drop'),
        weight: set.weight ?? '',
        repsU: set.repsU ?? '',
        repsA: set.repsA ?? '',
        seconds: set.seconds ?? '',
        warmup: !!set.warmup,
        round: set.round ?? null
      };
    }

    function createBlankRow(timed, round = null) {
      return {
        id: createId('row'),
        weight: timed ? '' : '',
        repsU: '',
        repsA: '',
        seconds: timed ? '' : '',
        warmup: false,
        round,
        drops: [],
        memo: ''
      };
    }

    function createBlankDrop(timed, round = null) {
      return {
        id: createId('drop'),
        weight: timed ? '' : '',
        repsU: '',
        repsA: '',
        seconds: timed ? '' : '',
        warmup: false,
        round
      };
    }

    function createBuffer(timed) {
      return {
        row: createBlankRow(timed),
        drops: []
      };
    }

    function renderSet() {
      const container = document.querySelector('[data-route="#/set"]');
      container.innerHTML = '';
      const editor = uiState.setEditor;
      if (!editor) {
        const message = document.createElement('p');
        message.className = 'text-sm text-slate-500';
        message.textContent = '編集対象の種目が選択されていません。';
        container.appendChild(message);
        return;
      }
      const section = document.createElement('section');
      section.className = 'section-card bg-white p-4 space-y-4';

      // スーパーセット時はラウンド（セット）単位で表示
      if (editor.isSuperset) {
        renderSupersetByRound(editor, section);
      } else {
        // 単独種目の場合
        const active = editor.items[editor.activeIndex];
        const item = state.day.items.find(it => it.id === active.itemId);
        if (!item) {
          container.appendChild(section);
          return;
        }

        const subtitle = [item.gear, item.attachment, item.angle, item.position]
          .map(value => (value && value !== '-') ? value : '―')
          .join(' / ');
        const header = document.createElement('div');
        header.className = 'flex items-start justify-between gap-3 mb-2';
        const headerLeft = document.createElement('div');
        headerLeft.innerHTML = `
          <h2 class="text-lg font-light sumi-text" style="letter-spacing: 0.03em;">${item.exercise}</h2>
          <p class="text-[10px] sumi-text-light font-light mt-0.5">${subtitle}</p>
        `;
        header.appendChild(headerLeft);
        
        const editExerciseBtn = document.createElement('button');
        editExerciseBtn.type = 'button';
        editExerciseBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
        editExerciseBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
        editExerciseBtn.textContent = '種目を編集';
        editExerciseBtn.addEventListener('click', () => {
          // 現在の種目情報をformStateに設定
          uiState.formState = {
            part: item.part,
            exercise: item.exercise,
            gear: item.gear,
            attachment: item.attachment,
            angle: item.angle,
            position: item.position,
            timed: item.timed,
            oneHand: item.oneHand
          };
          navigate('#/exercise');
        });
        header.appendChild(editExerciseBtn);
        section.appendChild(header);

        const rowsWrapper = document.createElement('div');
        rowsWrapper.className = 'space-y-2.5';
        renderRows(active, rowsWrapper);
        section.appendChild(rowsWrapper);
      }

      // 共通のフッター
      const footer = createSetFooter(editor);
      section.appendChild(footer);
      container.appendChild(section);
    }

    function renderSupersetByRound(editor, section) {
      // 最大ラウンド数を取得
      const maxRounds = Math.max(...editor.items.map(item => {
        const rounds = new Set(item.rows.filter(r => r.round != null).map(r => r.round));
        return rounds.size > 0 ? Math.max(...rounds) : 0;
      }));

      // ラウンドごとに表示
      for (let round = 0; round <= maxRounds; round++) {
        const roundCard = document.createElement('div');
        roundCard.className = 'border rounded-xl p-3 space-y-3';
        roundCard.style.borderColor = 'rgba(212, 175, 55, 0.25)';
        roundCard.style.backgroundColor = 'rgba(245, 237, 214, 0.05)';

        // 各種目のこのラウンドのセットを表示
        editor.items.forEach((activeItem, itemIndex) => {
          const item = state.day.items.find(it => it.id === activeItem.itemId);
          if (!item) return;

          const rowsForRound = activeItem.rows.filter(r => r.round === round);
          if (rowsForRound.length === 0) return;

          const subtitle = [item.gear, item.attachment, item.angle, item.position]
            .map(value => (value && value !== '-') ? value : '―')
            .join(' / ');

          const exerciseBlock = document.createElement('div');
          exerciseBlock.className = 'space-y-2';

          const header = document.createElement('div');
          header.innerHTML = `
            <div class="flex items-center gap-2">
              <span class="text-xs font-light px-1.5 py-0.5 rounded" style="background-color: var(--color-gold); color: white;">${activeItem.label}</span>
              <h4 class="text-sm font-light sumi-text" style="letter-spacing: 0.02em;">${item.exercise}</h4>
            </div>
            <p class="text-[10px] sumi-text-light font-light mt-0.5">${subtitle}</p>
          `;
          exerciseBlock.appendChild(header);

          // このラウンドのセットを表示
          rowsForRound.forEach((row, rowIndex) => {
            const actualRowIndex = activeItem.rows.indexOf(row);
            const rowCard = createSetInputCard(row, actualRowIndex, activeItem, item.timed, item.dropset);
            exerciseBlock.appendChild(rowCard);
          });

          roundCard.appendChild(exerciseBlock);
        });

        section.appendChild(roundCard);
      }

      // セット追加ボタン
      const addRoundBtn = document.createElement('button');
      addRoundBtn.type = 'button';
      addRoundBtn.className = 'w-full text-xs font-light px-3 py-2 bg-white rounded-lg min-h-[32px] border transition';
      addRoundBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
      addRoundBtn.style.color = 'var(--color-gold)';
      addRoundBtn.textContent = '＋ ラウンド追加';
      addRoundBtn.addEventListener('click', () => {
        const nextRound = maxRounds + 1;
        editor.items.forEach(activeItem => {
          activeItem.rows.push({
            round: nextRound,
            weight: null,
            repsU: null,
            repsA: 0,
            seconds: null,
            warmup: false,
            drops: []
          });
        });
        renderSet();
      });
      section.appendChild(addRoundBtn);
    }

    function createSetInputCard(row, rowIndex, activeItem, isTimed, isDropsetEnabled) {
      const rowCard = document.createElement('div');
      rowCard.className = 'bg-white rounded-xl p-2.5 space-y-2 border border-neutral-200/40 shadow-sm';

      const grid = document.createElement('div');
      grid.className = 'flex gap-2 text-sm sumi-text';
      if (isTimed) {
        grid.appendChild(createCompactNumberInput('秒数', row.seconds, value => { row.seconds = value; }));
      } else {
        grid.appendChild(createCompactNumberInput('重量', row.weight, value => { row.weight = value; }));
        grid.appendChild(createCompactNumberInput('自力', row.repsU, value => { row.repsU = value; }));
        grid.appendChild(createCompactNumberInput('補助', row.repsA, value => { row.repsA = value; }, 0));
      }
      rowCard.appendChild(grid);

      const toggles = document.createElement('div');
      toggles.className = 'flex items-center justify-between gap-2 text-sm sumi-text';
      const warmupLabel = document.createElement('label');
      warmupLabel.className = 'inline-flex items-center gap-1 text-xs sumi-text-light cursor-pointer';
      const warmupInput = document.createElement('input');
      warmupInput.type = 'checkbox';
      warmupInput.className = 'w-3 h-3 rounded';
      warmupInput.style.accentColor = 'var(--color-gold)';
      warmupInput.checked = row.warmup;
      warmupInput.addEventListener('change', () => { row.warmup = warmupInput.checked; });
      warmupLabel.append(warmupInput, document.createTextNode('W'));
      toggles.appendChild(warmupLabel);
      
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'text-xs font-light px-3 py-1 transition';
      removeBtn.style.color = 'var(--color-sumi-light)';
      removeBtn.textContent = 'このセットを削除';
      removeBtn.addEventListener('click', () => {
        activeItem.rows.splice(rowIndex, 1);
        renderSet();
      });
      toggles.appendChild(removeBtn);
      rowCard.appendChild(toggles);

      // セットメモ入力欄（ウォームアップの下）
      const memoInput = document.createElement('input');
      memoInput.type = 'text';
      memoInput.className = 'w-full px-2 py-1 text-xs rounded-lg border transition';
      memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
      memoInput.style.backgroundColor = 'rgba(245, 237, 214, 0.05)';
      memoInput.placeholder = 'セットメモ...';
      memoInput.value = row.memo || '';
      memoInput.addEventListener('input', () => { row.memo = memoInput.value; });
      memoInput.addEventListener('focus', () => {
        memoInput.style.outline = 'none';
        memoInput.style.borderColor = 'var(--color-gold)';
        memoInput.style.boxShadow = '0 0 0 3px rgba(212, 175, 55, 0.1)';
      });
      memoInput.addEventListener('blur', () => {
        memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
        memoInput.style.boxShadow = 'none';
      });
      rowCard.appendChild(memoInput);

      // ドロップセットエリア（後で削除予定）
      const dropArea = document.createElement('div');
      dropArea.className = 'space-y-2.5';
      row.drops.forEach((drop, dropIndex) => {
        const dropCard = document.createElement('div');
        dropCard.className = 'rounded-lg p-2.5 space-y-2 border border-dashed';
        dropCard.style.borderColor = 'rgba(212, 175, 55, 0.3)';
        dropCard.style.backgroundColor = 'rgba(245, 237, 214, 0.15)';
        const dropTitle = document.createElement('p');
        dropTitle.className = 'text-[10px] font-light';
        dropTitle.style.color = 'var(--color-gold)';
        dropTitle.textContent = 'ドロップセット';
        dropCard.appendChild(dropTitle);
        const dropGrid = document.createElement('div');
        dropGrid.className = 'flex gap-2 text-sm sumi-text';
        if (isTimed) {
          dropGrid.appendChild(createCompactNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
        } else {
          dropGrid.appendChild(createCompactNumberInput('重量', drop.weight, value => { drop.weight = value; }));
          dropGrid.appendChild(createCompactNumberInput('自力', drop.repsU, value => { drop.repsU = value; }));
          dropGrid.appendChild(createCompactNumberInput('補助', drop.repsA, value => { drop.repsA = value; }, 0));
        }
        dropCard.appendChild(dropGrid);
        const dropToggle = document.createElement('label');
        dropToggle.className = 'inline-flex items-center gap-1 text-[10px] sumi-text-light cursor-pointer';
        const dropWarm = document.createElement('input');
        dropWarm.type = 'checkbox';
        dropWarm.className = 'w-3 h-3 rounded';
        dropWarm.style.accentColor = 'var(--color-gold)';
        dropWarm.checked = drop.warmup;
        dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; });
        dropToggle.append(dropWarm, document.createTextNode('W'));
        dropCard.appendChild(dropToggle);
        const dropFooter = document.createElement('div');
        dropFooter.className = 'flex justify-end';
        const dropRemove = document.createElement('button');
        dropRemove.type = 'button';
        dropRemove.className = 'text-[10px] font-light px-2 py-0.5 transition';
        dropRemove.style.color = 'var(--color-sumi-light)';
        dropRemove.textContent = '削除';
        dropRemove.addEventListener('click', () => {
          row.drops.splice(dropIndex, 1);
          renderSet();
        });
        dropFooter.appendChild(dropRemove);
        dropCard.appendChild(dropFooter);
        dropArea.appendChild(dropCard);
      });
      if (row.drops.length > 0) {
        rowCard.appendChild(dropArea);
      }

      // ドロップセットが有効な場合のみボタンを表示
      if (isDropsetEnabled) {
        const addDropBtn = document.createElement('button');
        addDropBtn.type = 'button';
        addDropBtn.className = 'w-full text-[10px] font-light px-2 py-1.5 rounded-lg border transition';
        addDropBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
        addDropBtn.style.color = 'var(--color-gold)';
        addDropBtn.textContent = '＋ ドロップセット';
        addDropBtn.addEventListener('click', () => {
          row.drops.push({
            weight: null,
            repsU: null,
            repsA: 0,
            seconds: null,
            warmup: false
          });
          renderSet();
        });
        rowCard.appendChild(addDropBtn);
      }

      return rowCard;
    }

    function renderRows(active, rowsWrapper) {
      active.rows.forEach((row, rowIndex) => {
        const rowCard = document.createElement('div');
        rowCard.className = 'bg-white rounded-xl p-2.5 space-y-2 border border-neutral-200/40 shadow-sm';
        if (row.round != null) {
          const title = document.createElement('div');
          title.className = 'flex items-center justify-between text-xs sumi-text-mid font-light';
          title.textContent = `ラウンド ${row.round}`;
          rowCard.appendChild(title);
        }

        const grid = document.createElement('div');
        grid.className = 'flex gap-2 text-sm sumi-text';
        if (active.timed) {
          grid.appendChild(createCompactNumberInput('秒数', row.seconds, value => { row.seconds = value; }));
        } else {
          grid.appendChild(createCompactNumberInput('重量', row.weight, value => { row.weight = value; }));
          grid.appendChild(createCompactNumberInput('自力', row.repsU, value => { row.repsU = value; }));
          grid.appendChild(createCompactNumberInput('補助', row.repsA, value => { row.repsA = value; }, 0));
        }
        rowCard.appendChild(grid);

        const toggles = document.createElement('div');
        toggles.className = 'flex items-center justify-between gap-2 text-sm sumi-text';
        const warmupLabel = document.createElement('label');
        warmupLabel.className = 'inline-flex items-center gap-1 text-xs sumi-text-light cursor-pointer';
        const warmupInput = document.createElement('input');
        warmupInput.type = 'checkbox';
        warmupInput.className = 'w-3 h-3 rounded';
        warmupInput.style.accentColor = 'var(--color-gold)';
        warmupInput.checked = row.warmup;
        warmupInput.addEventListener('change', () => { row.warmup = warmupInput.checked; });
        warmupLabel.append(warmupInput, document.createTextNode('W'));
        toggles.appendChild(warmupLabel);
        
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'text-xs font-light px-3 py-1 transition';
        removeBtn.style.color = 'var(--color-sumi-light)';
        removeBtn.textContent = 'このセットを削除';
        removeBtn.addEventListener('click', () => {
          active.rows.splice(rowIndex, 1);
          if (active.rows.length === 0) {
            active.rows.push(createBlankRow(active.timed));
          }
          renderSet();
        });
        toggles.appendChild(removeBtn);
        rowCard.appendChild(toggles);

        // セットメモ入力欄（ウォームアップの下）
        const memoInput = document.createElement('input');
        memoInput.type = 'text';
        memoInput.className = 'w-full px-2 py-1 text-xs rounded-lg border transition';
        memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
        memoInput.style.backgroundColor = 'rgba(245, 237, 214, 0.05)';
        memoInput.placeholder = 'セットメモ...';
        memoInput.value = row.memo || '';
        memoInput.addEventListener('input', () => { row.memo = memoInput.value; });
        memoInput.addEventListener('focus', () => {
          memoInput.style.outline = 'none';
          memoInput.style.borderColor = 'var(--color-gold)';
          memoInput.style.boxShadow = '0 0 0 3px rgba(212, 175, 55, 0.1)';
        });
        memoInput.addEventListener('blur', () => {
          memoInput.style.borderColor = 'rgba(212, 175, 55, 0.2)';
          memoInput.style.boxShadow = 'none';
        });
        rowCard.appendChild(memoInput);

        const dropArea = document.createElement('div');
        dropArea.className = 'space-y-2.5';
        row.drops.forEach((drop, dropIndex) => {
          const dropCard = document.createElement('div');
          dropCard.className = 'rounded-lg p-2.5 space-y-2 border border-dashed';
          dropCard.style.borderColor = 'rgba(212, 175, 55, 0.3)';
          dropCard.style.backgroundColor = 'rgba(245, 237, 214, 0.15)';
          const dropTitle = document.createElement('p');
          dropTitle.className = 'text-[10px] font-light';
          dropTitle.style.color = 'var(--color-gold)';
          dropTitle.textContent = 'ドロップセット';
          dropCard.appendChild(dropTitle);
          const dropGrid = document.createElement('div');
          dropGrid.className = 'flex gap-2 text-sm sumi-text';
          if (active.timed) {
            dropGrid.appendChild(createCompactNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
          } else {
            dropGrid.appendChild(createCompactNumberInput('重量', drop.weight, value => { drop.weight = value; }));
            dropGrid.appendChild(createCompactNumberInput('自力', drop.repsU, value => { drop.repsU = value; }));
            dropGrid.appendChild(createCompactNumberInput('補助', drop.repsA, value => { drop.repsA = value; }, 0));
          }
          dropCard.appendChild(dropGrid);
          const dropToggle = document.createElement('label');
          dropToggle.className = 'inline-flex items-center gap-1 text-[10px] sumi-text-light cursor-pointer';
          const dropWarm = document.createElement('input');
          dropWarm.type = 'checkbox';
          dropWarm.className = 'w-3 h-3 rounded';
          dropWarm.style.accentColor = 'var(--color-gold)';
          dropWarm.checked = drop.warmup;
          dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; });
          dropToggle.append(dropWarm, document.createTextNode('W'));
          dropCard.appendChild(dropToggle);
          const dropFooter = document.createElement('div');
          dropFooter.className = 'flex justify-end';
          const dropRemove = document.createElement('button');
          dropRemove.type = 'button';
          dropRemove.className = 'text-[10px] font-light px-2 py-0.5 transition';
          dropRemove.style.color = 'var(--color-sumi-light)';
          dropRemove.textContent = '削除';
          dropRemove.addEventListener('click', () => {
            row.drops.splice(dropIndex, 1);
            renderSet();
          });
          dropFooter.appendChild(dropRemove);
          dropCard.appendChild(dropFooter);
          dropArea.appendChild(dropCard);
        });
        // ドロップセットが有効な場合のみボタンを表示
        if (active.dropset) {
          const addDropBtn = document.createElement('button');
          addDropBtn.type = 'button';
          addDropBtn.className = 'w-full text-xs font-light px-4 py-2 bg-white rounded-xl min-h-[36px] border transition';
          addDropBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
          addDropBtn.style.color = 'var(--color-gold)';
          addDropBtn.textContent = '＋ ドロップセット';
          addDropBtn.addEventListener('click', () => {
            row.drops.push(createBlankDrop(active.timed, row.round));
            renderSet();
          });
          dropArea.appendChild(addDropBtn);
        }
        rowCard.appendChild(dropArea);

        rowsWrapper.appendChild(rowCard);
      });
      
      const addSetBtn = document.createElement('button');
      addSetBtn.type = 'button';
      addSetBtn.className = 'w-full text-xs font-light px-3 py-2 bg-white rounded-lg min-h-[32px] border transition';
      addSetBtn.style.borderColor = 'rgba(212, 175, 55, 0.2)';
      addSetBtn.style.color = 'var(--color-gold)';
      addSetBtn.textContent = '＋ セット追加';
      addSetBtn.addEventListener('click', () => {
        active.rows.push(createBlankRow(active.timed));
        renderSet();
      });
      rowsWrapper.appendChild(addSetBtn);
    }

    function createSetFooter(editor) {
      const footer = document.createElement('div');
      footer.className = 'flex flex-col sm:flex-row gap-2.5 justify-between pt-2';
      const saveBack = document.createElement('button');
      saveBack.type = 'button';
      saveBack.className = 'ios-card text-white px-6 py-3 font-light min-h-[44px] transition';
      saveBack.style.backgroundColor = 'var(--color-gold)';
      saveBack.style.letterSpacing = '0.05em';
      saveBack.textContent = '保存して戻る';
      saveBack.addEventListener('click', () => {
        persistSetEditor();
        navigate('#/today');
      });
      const saveNext = document.createElement('button');
      saveNext.type = 'button';
      saveNext.className = 'ios-card bg-white px-6 py-3 font-light min-h-[44px] border transition';
      saveNext.style.borderColor = 'rgba(212, 175, 55, 0.3)';
      saveNext.style.color = 'var(--color-gold)';
      saveNext.textContent = '次の種目へ';
      saveNext.addEventListener('click', () => {
        persistSetEditor();
        uiState.exerciseForm = createExerciseFormState();
        navigate('#/exercise');
      });
      footer.append(saveBack, saveNext);
      return footer;
    }

    function renderRoundBuffer(editor) {
      const wrapper = document.createElement('div');
      wrapper.className = 'space-y-4 bg-indigo-50 rounded-2xl p-4 border border-indigo-200';
      const title = document.createElement('div');
      title.className = 'flex items-center justify-between';
      title.innerHTML = `
        <div>
          <p class="text-sm font-semibold text-indigo-700">ラウンド入力</p>
          <p class="text-xs text-indigo-500">現在のラウンド番号: ${editor.nextRound}</p>
        </div>
        <button type="button" class="ios-card bg-indigo-500 text-white px-4 py-2 text-sm font-semibold min-h-[40px]" id="nextRoundBtn">次ラウンドへ</button>
      `;
      wrapper.appendChild(title);
      const activeBuffer = editor.cycleBuffers[editor.activeIndex];
      const activeItem = editor.items[editor.activeIndex];
      const grid = document.createElement('div');
      grid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-indigo-700';
      if (activeItem.timed) {
        grid.appendChild(createNumberInput('秒数', activeBuffer.row.seconds, value => { activeBuffer.row.seconds = value; }));
      } else {
        grid.appendChild(createNumberInput('重量(kg)', activeBuffer.row.weight, value => { activeBuffer.row.weight = value; }));
        grid.appendChild(createNumberInput('自力レップ', activeBuffer.row.repsU, value => { activeBuffer.row.repsU = value; }));
        grid.appendChild(createNumberInput('補助レップ', activeBuffer.row.repsA, value => { activeBuffer.row.repsA = value; }, 0));
      }
      wrapper.appendChild(grid);
      const warmupRow = document.createElement('label');
      warmupRow.className = 'inline-flex items-center gap-1 text-xs sumi-text-light min-h-[32px]';
      const warmupInput = document.createElement('input');
      warmupInput.type = 'checkbox';
      warmupInput.className = 'w-3 h-3 rounded';
      warmupInput.style.accentColor = 'var(--color-gold)';
      warmupInput.checked = activeBuffer.row.warmup;
      warmupInput.addEventListener('change', () => { activeBuffer.row.warmup = warmupInput.checked; });
      warmupRow.append(warmupInput, document.createTextNode('W'));
      wrapper.appendChild(warmupRow);

      activeBuffer.drops.forEach((drop, index) => {
        const dropCard = document.createElement('div');
        dropCard.className = 'bg-white rounded-2xl p-4 space-y-3 border border-dashed border-indigo-200';
        const dropTitle = document.createElement('p');
        dropTitle.className = 'text-xs font-semibold text-indigo-600';
        dropTitle.textContent = 'ドロップセット';
        dropCard.appendChild(dropTitle);
        const dropGrid = document.createElement('div');
        dropGrid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-indigo-700';
        if (activeItem.timed) {
          dropGrid.appendChild(createNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
        } else {
          dropGrid.appendChild(createNumberInput('重量(kg)', drop.weight, value => { drop.weight = value; }));
          dropGrid.appendChild(createNumberInput('自力レップ', drop.repsU, value => { drop.repsU = value; }));
          dropGrid.appendChild(createNumberInput('補助レップ', drop.repsA, value => { drop.repsA = value; }, 0));
        }
        dropCard.appendChild(dropGrid);
        const dropToggle = document.createElement('label');
        dropToggle.className = 'inline-flex items-center gap-1 text-xs sumi-text-light min-h-[32px]';
        const dropWarm = document.createElement('input');
        dropWarm.type = 'checkbox';
        dropWarm.className = 'w-3 h-3 rounded';
        dropWarm.style.accentColor = 'var(--color-gold)';
        dropWarm.checked = drop.warmup;
        dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; });
        dropToggle.append(dropWarm, document.createTextNode('W'));
        dropCard.appendChild(dropToggle);
        const dropFooter = document.createElement('div');
        dropFooter.className = 'flex justify-end';
        const dropRemove = document.createElement('button');
        dropRemove.type = 'button';
        dropRemove.className = 'text-xs text-rose-500 font-semibold px-3 py-1 min-h-[32px]';
        dropRemove.textContent = '削除';
        dropRemove.addEventListener('click', () => {
          activeBuffer.drops.splice(index, 1);
          renderSet();
        });
        dropFooter.appendChild(dropRemove);
        dropCard.appendChild(dropFooter);
        wrapper.appendChild(dropCard);
      });

      const addDropBtn = document.createElement('button');
      addDropBtn.type = 'button';
      addDropBtn.className = 'w-full text-xs text-indigo-500 font-semibold px-4 py-2 bg-white rounded-2xl min-h-[40px]';
      addDropBtn.textContent = '＋ ドロップセット';
      addDropBtn.addEventListener('click', () => {
        activeBuffer.drops.push(createBlankDrop(activeItem.timed));
        renderSet();
      });
      wrapper.appendChild(addDropBtn);

      wrapper.querySelector('#nextRoundBtn').addEventListener('click', () => {
        advanceRoundCycle();
      });

      return wrapper;
    }

    function createCompactNumberInput(labelText, value, onInput, min = 0) {
      const wrapper = document.createElement('label');
      wrapper.className = 'flex-1 flex flex-col gap-1';
      const label = document.createElement('span');
      label.className = 'text-[10px] sumi-text-mid font-light';
      label.textContent = labelText;
      wrapper.appendChild(label);
      const input = document.createElement('input');
      input.type = 'number';
      input.inputMode = 'numeric';
      input.min = String(min);
      input.value = value ?? '';
      input.className = 'rounded-lg border px-2 py-1.5 text-sm sumi-text font-light transition focus:outline-none focus:ring-1 w-full';
      input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
      input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      input.addEventListener('focus', () => {
        input.style.borderColor = 'var(--color-gold)';
        input.style.backgroundColor = 'rgba(245, 237, 214, 0.1)';
      });
      input.addEventListener('blur', () => {
        input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
        input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      });
      input.addEventListener('input', () => onInput(input.value));
      wrapper.appendChild(input);
      return wrapper;
    }

    function createNumberInput(labelText, value, onInput, min = 0) {
      const wrapper = document.createElement('label');
      wrapper.className = 'flex flex-col gap-1.5';
      const label = document.createElement('span');
      label.className = 'text-xs sumi-text-mid font-light';
      label.textContent = labelText;
      wrapper.appendChild(label);
      const input = document.createElement('input');
      input.type = 'number';
      input.inputMode = 'numeric';
      input.min = String(min);
      input.value = value ?? '';
      input.className = 'rounded-lg border px-3 py-2 text-sm sumi-text font-light transition focus:outline-none focus:ring-1';
      input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
      input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      input.addEventListener('focus', () => {
        input.style.borderColor = 'var(--color-gold)';
        input.style.backgroundColor = 'rgba(245, 237, 214, 0.1)';
      });
      input.addEventListener('blur', () => {
        input.style.borderColor = 'rgba(115, 115, 115, 0.2)';
        input.style.backgroundColor = 'rgba(250, 250, 250, 0.5)';
      });
      input.addEventListener('input', () => onInput(input.value));
      wrapper.appendChild(input);
      return wrapper;
    }

    function bufferHasData(buffer, timed) {
      if (timed) {
        return buffer.row.seconds !== '' || buffer.drops.some(drop => drop.seconds !== '');
      }
      const baseFilled = buffer.row.weight !== '' || buffer.row.repsU !== '' || buffer.row.repsA !== '';
      const dropFilled = buffer.drops.some(drop => drop.weight !== '' || drop.repsU !== '' || drop.repsA !== '');
      return baseFilled || dropFilled;
    }

    function advanceRoundCycle() {
      const editor = uiState.setEditor;
      if (!editor || !editor.isSuperset) return;
      const buffer = editor.cycleBuffers[editor.activeIndex];
      editor.activeIndex = (editor.activeIndex + 1) % editor.items.length;
      if (editor.activeIndex === 0) {
        finalizeRoundBuffer();
      } else {
        renderSet();
      }
    }

    function finalizeRoundBuffer() {
      const editor = uiState.setEditor;
      if (!editor) return;
      const entries = editor.cycleBuffers.map((buffer, index) => {
        const item = editor.items[index];
        if (!bufferHasData(buffer, item.timed)) return null;
        const row = createBlankRow(item.timed, editor.nextRound);
        row.weight = buffer.row.weight;
        row.repsU = buffer.row.repsU;
        row.repsA = buffer.row.repsA;
        row.seconds = buffer.row.seconds;
        row.warmup = buffer.row.warmup;
        row.drops = buffer.drops.map(drop => ({
          id: createId('drop'),
          weight: drop.weight,
          repsU: drop.repsU,
          repsA: drop.repsA,
          seconds: drop.seconds,
          warmup: drop.warmup,
          round: editor.nextRound
        }));
        return row;
      });
      const hasAny = entries.some(entry => entry !== null);
      if (hasAny) {
        entries.forEach((row, index) => {
          if (!row) return;
          editor.items[index].rows.push(row);
        });
        editor.nextRound += 1;
      }
      editor.cycleBuffers = editor.items.map(item => createBuffer(item.timed));
      renderSet();
    }

    function persistSetEditor() {
      const editor = uiState.setEditor;
      if (!editor) return;
      editor.items.forEach(itemState => {
        const item = state.day.items.find(it => it.id === itemState.itemId);
        if (!item) return;
        const newSets = [];
        itemState.rows.forEach(row => {
          const built = buildSetsFromRow(row, itemState.timed);
          built.forEach(set => newSets.push(set));
        });
        item.sets = newSets;
      });
      state.day.items.sort((a, b) => a.order - b.order).forEach((entry, index) => {
        entry.order = index + 1;
      });
      renderToday();
    }

    function buildSetsFromRow(row, timed) {
      const sets = [];
      const base = convertRowToSet(row, timed, false);
      if (base) sets.push(base);
      row.drops.forEach(drop => {
        const dropSet = convertRowToSet({ ...drop, round: drop.round ?? row.round }, timed, true);
        if (dropSet) sets.push(dropSet);
      });
      return sets;
    }

    function convertRowToSet(row, timed, isDrop) {
      if (timed) {
        const seconds = parseNumber(row.seconds);
        if (seconds == null) return null;
        return createSet({ seconds, warmup: !!row.warmup, drop: isDrop, round: row.round ?? null });
      }
      const weight = parseNumber(row.weight);
      const repsU = parseNumber(row.repsU);
      const repsA = parseNumber(row.repsA);
      if (weight == null && repsU == null && repsA == null) return null;
      return createSet({ weight, repsU, repsA, warmup: !!row.warmup, drop: isDrop, round: row.round ?? null });
    }

    function parseNumber(value) {
      if (value === '' || value === null || value === undefined) return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    }

    function renderHistory() {
      const container = document.querySelector('[data-route="#/history"]');
      container.innerHTML = '';
      
      const header = document.createElement('div');
      header.className = 'flex items-center justify-between mb-3';
      const title = document.createElement('h1');
      title.className = 'text-lg font-light sumi-text';
      title.style.letterSpacing = '0.05em';
      title.textContent = 'トレーニング履歴';
      header.appendChild(title);
      const homeButton = document.createElement('button');
      homeButton.type = 'button';
      homeButton.className = 'flex items-center gap-1 text-sm font-light sumi-text-light hover:sumi-text transition min-h-[44px] px-3';
      homeButton.innerHTML = '← ホーム';
      homeButton.addEventListener('click', () => navigate('#/dashboard'));
      header.appendChild(homeButton);
      container.appendChild(header);
      
      if (state.history.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'section-card bg-white p-6 text-center';
        empty.innerHTML = `
          <p class="text-sm sumi-text-light font-light">まだ履歴がありません</p>
          <p class="text-xs sumi-text-light font-light mt-2">トレーニングを完了すると履歴が記録されます</p>
        `;
        container.appendChild(empty);
        return;
      }
      
      const list = document.createElement('div');
      list.className = 'space-y-3';
      
      state.history.forEach((workout, workoutIndex) => {
        const card = document.createElement('article');
        card.className = 'section-card bg-white p-4 space-y-3';
        
        const header = document.createElement('div');
        header.className = 'flex items-start justify-between gap-3';
        const date = new Date(workout.date);
        const dateStr = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
        const headerLeft = document.createElement('div');
        headerLeft.className = 'min-w-0';
        headerLeft.innerHTML = `
          <p class="text-base font-light sumi-text" style="letter-spacing: 0.02em;">${dateStr}</p>
          <p class="text-xs font-light sumi-text-light">${workout.items.length}種目</p>
        `;
        header.appendChild(headerLeft);
        
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'flex gap-2';
        
        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
        editBtn.style.cssText = 'background-color: rgba(245, 237, 214, 0.2); color: var(--color-gold); border-color: rgba(212, 175, 55, 0.3); letter-spacing: 0.05em;';
        editBtn.textContent = '編集';
        editBtn.addEventListener('click', () => {
          loadHistoryForEdit(workoutIndex);
        });
        buttonGroup.appendChild(editBtn);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'px-3 py-1.5 rounded-full text-xs font-light min-h-[36px] border transition';
        deleteBtn.style.cssText = 'background-color: rgba(254, 226, 226, 0.5); color: #dc2626; border-color: rgba(220, 38, 38, 0.3); letter-spacing: 0.05em;';
        deleteBtn.textContent = '削除';
        deleteBtn.addEventListener('click', () => {
          deleteWorkout(workoutIndex);
        });
        buttonGroup.appendChild(deleteBtn);
        
        header.appendChild(buttonGroup);
        card.appendChild(header);
        
        const itemsList = document.createElement('div');
        itemsList.className = 'space-y-2';
        
        const sortedItems = [...workout.items].sort((a, b) => a.order - b.order);
        const processedGroups = new Set();
        
        sortedItems.forEach(item => {
          if (item.mode === 'superset') {
            if (!item.groupId || processedGroups.has(item.groupId)) return;
            const groupItems = sortedItems.filter(candidate => candidate.groupId === item.groupId);
            processedGroups.add(item.groupId);
            itemsList.appendChild(buildHistorySuperset(groupItems));
          } else {
            itemsList.appendChild(buildHistorySingle(item));
          }
        });
        
        card.appendChild(itemsList);
        
        // メモを表示
        if (workout.memo && workout.memo.trim()) {
          const memoDiv = document.createElement('div');
          memoDiv.className = 'p-3 rounded-lg border border-dashed';
          memoDiv.style.cssText = 'border-color: rgba(212, 175, 55, 0.3); background-color: rgba(245, 237, 214, 0.1);';
          const memoLabel = document.createElement('p');
          memoLabel.className = 'text-xs font-light mb-1';
          memoLabel.style.color = 'var(--color-gold)';
          memoLabel.textContent = 'メモ';
          const memoText = document.createElement('p');
          memoText.className = 'text-sm font-light sumi-text whitespace-pre-wrap';
          memoText.textContent = workout.memo;
          memoDiv.appendChild(memoLabel);
          memoDiv.appendChild(memoText);
          card.appendChild(memoDiv);
        }
        
        list.appendChild(card);
      });
      
      container.appendChild(list);
    }
    
    function buildHistorySingle(item) {
      const div = document.createElement('div');
      div.className = 'p-3 rounded-lg border border-neutral-200/40';
      
      const partLabel = state.master.parts.find(p => p.id === item.part)?.label ?? '';
      const header = document.createElement('div');
      header.className = 'flex items-start justify-between gap-2 mb-2';
      header.innerHTML = `
        <div class="min-w-0">
          <p class="text-sm font-light sumi-text" style="letter-spacing: 0.02em;">${item.exercise}</p>
          <p class="text-xs font-light sumi-text-light">${partLabel}</p>
        </div>
        <div class="text-xs font-light sumi-text-light text-right min-w-0 truncate">
          ${[item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ')}
        </div>
      `;
      div.appendChild(header);
      
      const workSets = item.sets.filter(s => !s.warmup);
      const setsText = workSets.map(s => {
        if (s.seconds != null) return `${s.seconds}秒`;
        const parts = [];
        if (s.weight != null) parts.push(`${s.weight}kg`);
        if (s.repsU != null) parts.push(`×${s.repsU}`);
        return parts.join('');
      }).join(', ');
      
      const setsDiv = document.createElement('div');
      setsDiv.className = 'text-xs font-light sumi-text-light';
      setsDiv.textContent = setsText || 'セットなし';
      div.appendChild(setsDiv);
      
      return div;
    }
    
    function buildHistorySuperset(groupItems) {
      const sorted = [...groupItems].sort((a, b) => a.order - b.order);
      const labels = ['A', 'B', 'C'];
      const title = `(SS) ${sorted.map(item => item.exercise).join(' + ')}`;
      
      const div = document.createElement('div');
      div.className = 'p-3 rounded-lg border border-neutral-200/40';
      
      const header = document.createElement('div');
      header.className = 'flex items-start justify-between gap-2 mb-2';
      header.innerHTML = `
        <div class="min-w-0">
          <p class="text-sm font-light sumi-text" style="letter-spacing: 0.02em;">${title}</p>
          <p class="text-xs font-light sumi-text-light">${sorted.map((item, index) => `${labels[index]}. ${state.master.parts.find(p => p.id === item.part)?.label ?? ''}`).join(' / ')}</p>
        </div>
      `;
      div.appendChild(header);
      
      const rounds = buildSupersetRounds(sorted);
      const roundsText = `${rounds.length}ラウンド`;
      const roundsDiv = document.createElement('div');
      roundsDiv.className = 'text-xs font-light sumi-text-light';
      roundsDiv.textContent = roundsText;
      div.appendChild(roundsDiv);
      
      return div;
    }

    // LocalStorage functions
    function saveHistory() {
      try {
        localStorage.setItem('muscleRoutineHistory', JSON.stringify(state.history));
        localStorage.setItem('muscleRoutineHistoryVersion', '1');
      } catch (e) {
        console.error('Failed to save history:', e);
      }
    }

    function loadHistory() {
      try {
        const saved = localStorage.getItem('muscleRoutineHistory');
        if (saved) {
          state.history = JSON.parse(saved);
        }
      } catch (e) {
        console.error('Failed to load history:', e);
        state.history = [];
      }
    }

    function deleteWorkout(workoutIndex) {
      const workout = state.history[workoutIndex];
      const date = new Date(workout.date);
      const dateStr = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
      
      const confirmed = confirm(`${dateStr}のトレーニング履歴を削除しますか？\nこの操作は元に戻せません。`);
      if (!confirmed) return;
      
      // 履歴から削除
      state.history.splice(workoutIndex, 1);
      saveHistory();
      
      // 画面を再描画
      render();
      
      alert('履歴を削除しました。');
    }
    
    function loadHistoryForEdit(historyIndex) {
      // 履歴データをstate.dayに読み込む
      const workout = state.history[historyIndex];
      state.day = {
        date: workout.date,
        memo: workout.memo || '',
        items: JSON.parse(JSON.stringify(workout.items)) // deep copy
      };
      
      // 編集モードを設定
      uiState.editingHistoryIndex = historyIndex;
      
      // 今日のトレーニング画面に遷移
      navigate('#/today');
    }

    function completeWorkout() {
      const isEditing = uiState.editingHistoryIndex !== null;
      
      if (isEditing) {
        // 編集モード：履歴を更新
        const workout = {
          date: state.day.date,
          memo: state.day.memo || '',
          items: JSON.parse(JSON.stringify(state.day.items)), // deep copy
          completedAt: state.history[uiState.editingHistoryIndex].completedAt,
          updatedAt: new Date().toISOString()
        };
        state.history[uiState.editingHistoryIndex] = workout;
        saveHistory();
        
        // 編集モードを解除
        uiState.editingHistoryIndex = null;
        
        // 新しい日のデータを初期化
        state.day = {
          date: new Date().toISOString().slice(0, 10),
          memo: '',
          items: []
        };
        
        alert('履歴を更新しました！');
        navigate('#/history'); // 履歴画面に戻る
      } else {
        // 通常モード：今日のトレーニングをhistoryに追加
        const workout = {
          date: state.day.date,
          memo: state.day.memo || '',
          items: JSON.parse(JSON.stringify(state.day.items)), // deep copy
          completedAt: new Date().toISOString()
        };
        state.history.unshift(workout); // 最新を先頭に
        saveHistory();
        
        // 新しい日のデータを初期化
        state.day = {
          date: new Date().toISOString().slice(0, 10),
          memo: '',
          items: []
        };
        
        alert('トレーニングを完了しました！\n引き続き編集できます。');
        render(); // 画面を再描画
      }
    }

    function renderSettings() {
      const container = document.querySelector('[data-route="#/settings"]');
      container.innerHTML = '';
      
      // ヘッダー
      const header = document.createElement('div');
      header.className = 'flex items-center justify-between mb-3';
      const title = document.createElement('h1');
      title.className = 'text-lg font-light sumi-text';
      title.style.letterSpacing = '0.05em';
      title.textContent = '設定';
      header.appendChild(title);
      const homeButton = document.createElement('button');
      homeButton.type = 'button';
      homeButton.className = 'flex items-center gap-1 text-sm font-light sumi-text-light hover:sumi-text transition min-h-[44px] px-3';
      homeButton.innerHTML = '← ホーム';
      homeButton.addEventListener('click', () => navigate('#/dashboard'));
      header.appendChild(homeButton);
      container.appendChild(header);
      
      // データ管理セクション
      const dataSection = document.createElement('section');
      dataSection.className = 'section-card bg-white p-4 space-y-4';
      
      const dataSectionTitle = document.createElement('h2');
      dataSectionTitle.className = 'text-base font-light sumi-text';
      dataSectionTitle.style.letterSpacing = '0.05em';
      dataSectionTitle.textContent = 'データ管理';
      dataSection.appendChild(dataSectionTitle);
      
      // エクスポートボタン
      const exportBtn = document.createElement('button');
      exportBtn.type = 'button';
      exportBtn.className = 'w-full ios-card bg-white px-4 py-3 text-sm font-light transition min-h-[44px] border';
      exportBtn.style.cssText = 'border-color: rgba(212, 175, 55, 0.3); color: var(--color-gold); letter-spacing: 0.05em;';
      exportBtn.textContent = '📥 データをエクスポート';
      exportBtn.addEventListener('click', exportData);
      dataSection.appendChild(exportBtn);
      
      // インポートボタン
      const importBtn = document.createElement('button');
      importBtn.type = 'button';
      importBtn.className = 'w-full ios-card bg-white px-4 py-3 text-sm font-light transition min-h-[44px] border';
      importBtn.style.cssText = 'border-color: rgba(212, 175, 55, 0.3); color: var(--color-gold); letter-spacing: 0.05em;';
      importBtn.textContent = '📤 データをインポート';
      importBtn.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) importData(file);
        });
        input.click();
      });
      dataSection.appendChild(importBtn);
      
      // データクリアボタン
      const clearBtn = document.createElement('button');
      clearBtn.type = 'button';
      clearBtn.className = 'w-full ios-card bg-white px-4 py-3 text-sm font-light transition min-h-[44px] border';
      clearBtn.style.cssText = 'border-color: rgba(220, 38, 38, 0.3); color: #dc2626; letter-spacing: 0.05em;';
      clearBtn.textContent = '🗑️ すべてのデータを削除';
      clearBtn.addEventListener('click', clearAllData);
      dataSection.appendChild(clearBtn);
      
      container.appendChild(dataSection);
      
      // アプリ情報セクション
      const infoSection = document.createElement('section');
      infoSection.className = 'section-card bg-white p-4 space-y-3';
      
      const infoSectionTitle = document.createElement('h2');
      infoSectionTitle.className = 'text-base font-light sumi-text';
      infoSectionTitle.style.letterSpacing = '0.05em';
      infoSectionTitle.textContent = 'アプリ情報';
      infoSection.appendChild(infoSectionTitle);
      
      const versionInfo = document.createElement('div');
      versionInfo.className = 'text-sm font-light sumi-text-light space-y-1';
      versionInfo.innerHTML = `
        <p>バージョン: 1.0.0</p>
        <p>ビルドタグ: PHASE-5-20240529</p>
        <p class="text-xs mt-2">開発: Manus AI</p>
      `;
      infoSection.appendChild(versionInfo);
      
      container.appendChild(infoSection);
    }
    
    function exportData() {
      try {
        const exportObj = {
          version: '1.0.0',
          exportDate: new Date().toISOString(),
          data: {
            history: state.history,
            day: state.day
          }
        };
        
        const jsonStr = JSON.stringify(exportObj, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const dateStr = new Date().toISOString().slice(0, 10);
        a.download = `muscle-routine-backup-${dateStr}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        alert('データをエクスポートしました！');
      } catch (e) {
        alert('エクスポートに失敗しました: ' + e.message);
      }
    }
    
    function importData(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importObj = JSON.parse(e.target.result);
          
          if (!importObj.data || !importObj.data.history) {
            throw new Error('無効なデータ形式です');
          }
          
          const confirmed = confirm('データをインポートしますか？\n現在のデータは上書きされます。');
          if (!confirmed) return;
          
          state.history = importObj.data.history || [];
          if (importObj.data.day) {
            state.day = importObj.data.day;
          }
          
          saveHistory();
          render();
          
          alert(`データをインポートしました！\n履歴: ${state.history.length}件`);
        } catch (e) {
          alert('インポートに失敗しました: ' + e.message);
        }
      };
      reader.readAsText(file);
    }
    
    function clearAllData() {
      const confirmed = confirm('本当にすべてのデータを削除しますか？\nこの操作は元に戻せません。');
      if (!confirmed) return;
      
      const doubleConfirmed = confirm('最終確認: 本当に削除しますか？');
      if (!doubleConfirmed) return;
      
      try {
        localStorage.clear();
        state.history = [];
        state.day = {
          date: new Date().toISOString().slice(0, 10),
          memo: '',
          items: []
        };
        render();
        alert('すべてのデータを削除しました。');
        navigate('#/dashboard');
      } catch (e) {
        alert('削除に失敗しました: ' + e.message);
      }
    }

    function initialize() {
      loadHistory();
      handleNavigation(window.location.hash || '#/dashboard');
    }

    initialize();
  </script>
</body>
</html>
