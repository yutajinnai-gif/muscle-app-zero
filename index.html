<!DOCTYPE html>
<html lang="ja" class="h-full bg-slate-100">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BUILD_TAG=PHASE-5-20240529 | Muscle Routine</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    body { overflow-x: hidden; }
    :focus-visible { outline: 2px solid #6366f1; outline-offset: 2px; }
    ::-webkit-scrollbar { width: 0; height: 0; }
    .ios-card { border-radius: 24px; box-shadow: 0 12px 24px -16px rgba(15, 23, 42, 0.6); }
    .section-card { border-radius: 20px; box-shadow: 0 8px 20px -14px rgba(15, 23, 42, 0.8); }
  </style>
</head>
<body class="h-full text-slate-900">
  <div id="error-banner" class="hidden fixed top-0 left-0 right-0 z-50 flex items-center gap-2 bg-red-600 text-white px-4 py-3 shadow-lg">
    <span class="font-semibold">エラー</span>
    <span id="error-message" class="text-sm min-w-0 truncate"></span>
    <button type="button" id="error-dismiss" class="ml-auto text-xs font-semibold bg-white/15 hover:bg-white/25 rounded-full px-3 py-1 focus-visible:ring-2 focus-visible:ring-white/70 focus:outline-none min-h-[36px]">閉じる</button>
  </div>

  <main class="h-full max-w-3xl mx-auto px-4 pb-16 pt-20 flex flex-col gap-8">
    <header class="space-y-1">
      <h1 class="text-3xl font-semibold tracking-tight">Muscle Routine</h1>
      <p class="text-sm text-slate-500">URLと状態を同期するモバイルファーストのワークアウトプランナー。</p>
    </header>

    <section data-route="#/dashboard" class="route-view hidden flex flex-col gap-6"></section>
    <section data-route="#/today" class="route-view hidden flex flex-col gap-6"></section>
    <section data-route="#/exercise" class="route-view hidden flex flex-col gap-6"></section>
    <section data-route="#/set" class="route-view hidden flex flex-col gap-6"></section>
  </main>

  <script>
    const state = {
      schemaVersion: 2,
      master: {
        parts: [
          { id: 'chest', label: '胸' },
          { id: 'back', label: '背中' },
          { id: 'shoulder', label: '肩' },
          { id: 'arm', label: '腕' },
          { id: 'leg', label: '脚' },
          { id: 'core', label: '体幹' },
          { id: 'full', label: '全身' }
        ],
        exercises: {
          chest: ['インクラインダンベルプレス', 'ケーブルクロスオーバー', 'ダンベルフライ', 'ディクラインプレス', 'バーベルベンチプレス'],
          back: ['シーテッドロウ', 'デッドリフト', 'ベントオーバーロウ', 'ラットプルダウン', 'ワンハンドダンベルロウ'],
          shoulder: ['アーノルドプレス', 'サイドレイズ', 'ショルダープレス', 'フロントレイズ', 'リアデルトロウ'],
          arm: ['ケーブルプレスダウン', 'ダンベルキックバック', 'ハンマーカール', 'プリーチャーカール', 'ローププレスダウン'],
          leg: ['カーフレイズ', 'スクワット', 'デッドリフト（ルーマニアン）', 'レッグカール', 'レッグプレス'],
          core: ['アブホイール', 'ケーブルクランチ', 'プランク', 'ハンギングレッグレイズ'],
          full: ['ケトルベルスイング', 'バーピー', 'マウンテンクライマー', 'メディスンボールスラム']
        },
        gear: ['-', 'EZバー', 'ケーブル', 'ダンベル', 'マシン', 'バーベル', '自重'],
        attachments: ['-', 'Dハンドル', 'EZバーアタッチメント', 'ストレートバー', 'ロープ', 'ワイドバー'],
        angles: ['-', 'インクライン', 'オーバーヘッド', 'デクライン', 'フラット', 'ミッド'],
        positions: ['-', 'ニーリング', 'ナロー', 'ハーフスタンス', 'ワイド', '片脚']
      },
      history: [],
      day: {
        date: new Date().toISOString().slice(0, 10),
        items: [
          {
            id: createId('item'),
            order: 1,
            mode: 'single',
            groupId: null,
            part: 'chest',
            exercise: 'バーベルベンチプレス',
            gear: 'バーベル',
            attachment: '-',
            angle: 'フラット',
            position: '-',
            timed: false,
            oneHand: false,
            sets: [
              createSet({ weight: 60, repsU: 10, repsA: 0, warmup: true, drop: false, round: null, ts: Date.now() - 7200000 }),
              createSet({ weight: 80, repsU: 8, repsA: 0, warmup: false, drop: false, round: null, ts: Date.now() - 7100000 }),
              createSet({ weight: 60, repsU: 12, repsA: 0, warmup: false, drop: true, round: null, ts: Date.now() - 7090000 })
            ]
          },
          ...createSampleSuperset()
        ]
      }
    };

    const uiState = {
      route: null,
      exerciseForm: createExerciseFormState(),
      currentItemId: null,
      setEditor: null
    };

    function createId(prefix) {
      return `${prefix}-${Math.random().toString(36).slice(2, 11)}`;
    }

    function createSet({ weight = null, repsU = null, repsA = null, seconds = null, warmup = false, drop = false, round = null, ts = Date.now() }) {
      return { id: createId('set'), weight, repsU, repsA, seconds, warmup, drop, round, ts };
    }

    function createSampleSuperset() {
      const groupId = createGroupId();
      const now = Date.now();
      const baseTs = now - 3600000;
      const bench = {
        id: createId('item'),
        order: 2,
        mode: 'superset',
        groupId,
        part: 'chest',
        exercise: 'ダンベルフライ',
        gear: 'ダンベル',
        attachment: '-',
        angle: 'フラット',
        position: '-',
        timed: false,
        oneHand: false,
        sets: [
          createSet({ weight: 20, repsU: 12, repsA: 0, warmup: false, drop: false, round: 0, ts: baseTs }),
          createSet({ weight: 14, repsU: 12, repsA: 0, warmup: false, drop: true, round: 0, ts: baseTs + 1000 })
        ]
      };
      const pull = {
        id: createId('item'),
        order: 2.01,
        mode: 'superset',
        groupId,
        part: 'back',
        exercise: 'ラットプルダウン',
        gear: 'マシン',
        attachment: 'ワイドバー',
        angle: '-',
        position: '-',
        timed: false,
        oneHand: false,
        sets: [
          createSet({ weight: 55, repsU: 10, repsA: 0, warmup: false, drop: false, round: 0, ts: baseTs })
        ]
      };
      return [bench, pull];
    }

    function createGroupId() {
      return `grp_${Math.random().toString(36).slice(2, 8)}`;
    }

    function createExerciseFormState() {
      return {
        superset: false,
        cards: [createExerciseCardState('A')]
      };
    }

    function createExerciseCardState(label) {
      const firstPart = state.master.parts[0]?.id ?? '';
      const firstExercise = (state.master.exercises[firstPart] || [])[0] || '';
      return {
        key: createId('card'),
        label,
        part: firstPart,
        exercise: firstExercise,
        gear: '-',
        attachment: '-',
        angle: '-',
        position: '-',
        timed: false,
        oneHand: false
      };
    }

    function sortForDisplay(list) {
      return [...list].sort((a, b) => {
        if (a === '-') return -1;
        if (b === '-') return 1;
        return a.localeCompare(b, 'ja');
      });
    }

    function showError(message) {
      const banner = document.getElementById('error-banner');
      const text = document.getElementById('error-message');
      text.textContent = message;
      banner.classList.remove('hidden');
    }

    window.onerror = function(message, source, lineno, colno) {
      showError(`${message} (${lineno}:${colno})`);
    };

    window.onunhandledrejection = function(event) {
      showError(event.reason ? event.reason.toString() : 'Unhandled rejection');
    };

    window.__forceError = function() {
      setTimeout(() => {
        throw new Error('強制エラー発生');
      }, 0);
      Promise.reject(new Error('強制エラー発生'));
    };

    document.getElementById('error-dismiss').addEventListener('click', () => {
      document.getElementById('error-banner').classList.add('hidden');
    });

    function navigate(hash) {
      if (window.location.hash === hash) {
        handleNavigation(hash);
      } else {
        window.location.hash = hash;
      }
    }

    function handleNavigation(hash) {
      const valid = ['#/dashboard', '#/today', '#/exercise', '#/set'];
      const next = valid.includes(hash) ? hash : '#/dashboard';
      uiState.route = next;
      document.querySelectorAll('.route-view').forEach(section => {
        section.classList.toggle('hidden', section.getAttribute('data-route') !== next);
      });
      render();
    }

    window.addEventListener('hashchange', () => handleNavigation(window.location.hash));

    function render() {
      if (uiState.route === '#/dashboard') renderDashboard();
      if (uiState.route === '#/today') renderToday();
      if (uiState.route === '#/exercise') renderExercise();
      if (uiState.route === '#/set') renderSet();
    }

    function renderDashboard() {
      const container = document.querySelector('[data-route="#/dashboard"]');
      container.innerHTML = '';

      const navRow = document.createElement('div');
      navRow.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4';
      const buttons = [
        { label: '今日のトレーニング', handler: () => navigate('#/today'), classes: 'bg-indigo-500 text-white' },
        { label: '履歴', handler: () => alert('履歴は後日実装予定です。'), classes: 'bg-white text-slate-700' },
        { label: '設定', handler: () => alert('設定は後日実装予定です。'), classes: 'bg-white text-slate-700' }
      ];
      buttons.forEach(btn => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = `ios-card w-full px-6 py-4 text-lg font-semibold transition active:scale-[0.99] min-h-[44px] ${btn.classes}`;
        button.textContent = btn.label;
        button.addEventListener('click', btn.handler);
        navRow.appendChild(button);
      });
      container.appendChild(navRow);

      const statsCard = document.createElement('section');
      statsCard.className = 'section-card bg-white p-6 space-y-4';
      const todayStats = computeTodayStats();
      statsCard.innerHTML = `
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-semibold">今日の概要</h2>
          <span class="text-xs text-slate-400">ウォームアップ除外</span>
        </div>
        <div class="grid grid-cols-3 gap-3 text-center">
          <div class="ios-card bg-indigo-50 text-indigo-700 py-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs">作業セット</p>
            <p class="text-2xl font-semibold">${todayStats.workSets}</p>
          </div>
          <div class="ios-card bg-orange-50 text-orange-700 py-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs">SSラウンド</p>
            <p class="text-2xl font-semibold">${todayStats.supersetRounds}</p>
          </div>
          <div class="ios-card bg-emerald-50 text-emerald-700 py-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs">単独セット</p>
            <p class="text-2xl font-semibold">${todayStats.soloSets}</p>
          </div>
        </div>
      `;
      container.appendChild(statsCard);
    }

    function computeTodayStats() {
      const singles = state.day.items
        .filter(item => item.mode === 'single')
        .flatMap(item => item.sets)
        .filter(set => !set.warmup)
        .length;
      const roundMap = new Map();
      state.day.items
        .filter(item => item.mode === 'superset' && item.groupId)
        .forEach(item => {
          if (!roundMap.has(item.groupId)) roundMap.set(item.groupId, new Map());
          const groupRounds = roundMap.get(item.groupId);
          item.sets.forEach(set => {
            if (set.round === null || set.round === undefined) return;
            if (!groupRounds.has(set.round)) groupRounds.set(set.round, { hasWorking: false });
            if (!set.warmup) {
              groupRounds.get(set.round).hasWorking = true;
            }
          });
        });
      let supersetRounds = 0;
      roundMap.forEach(group => {
        group.forEach(entry => {
          if (entry.hasWorking) supersetRounds += 1;
        });
      });
      return {
        soloSets: singles,
        supersetRounds,
        workSets: singles + supersetRounds
      };
    }

    function renderToday() {
      const container = document.querySelector('[data-route="#/today"]');
      container.innerHTML = '';

      const statsSection = document.createElement('section');
      statsSection.className = 'section-card bg-white p-6 space-y-3';
      const summary = computeTodayStats();
      statsSection.innerHTML = `
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-semibold">今日の概要</h2>
          <span class="text-xs text-slate-400">ウォームアップ除外</span>
        </div>
        <div class="grid grid-cols-3 gap-3 text-center">
          <div class="ios-card bg-indigo-50 text-indigo-700 py-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs">作業セット</p>
            <p class="text-2xl font-semibold">${summary.workSets}</p>
          </div>
          <div class="ios-card bg-orange-50 text-orange-700 py-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs">SSラウンド</p>
            <p class="text-2xl font-semibold">${summary.supersetRounds}</p>
          </div>
          <div class="ios-card bg-emerald-50 text-emerald-700 py-3 min-h-[44px] flex flex-col justify-center">
            <p class="text-xs">単独セット</p>
            <p class="text-2xl font-semibold">${summary.soloSets}</p>
          </div>
        </div>
      `;
      container.appendChild(statsSection);

      const actionRow = document.createElement('div');
      actionRow.className = 'flex justify-between items-center gap-4';
      const addButton = document.createElement('button');
      addButton.type = 'button';
      addButton.className = 'ios-card bg-indigo-500 text-white px-6 py-3 font-semibold text-base min-h-[44px]';
      addButton.textContent = '＋ 種目追加';
      addButton.addEventListener('click', () => {
        uiState.exerciseForm = createExerciseFormState();
        navigate('#/exercise');
      });
      actionRow.appendChild(addButton);
      container.appendChild(actionRow);

      const list = document.createElement('div');
      list.className = 'space-y-4';
      const sortedItems = [...state.day.items].sort((a, b) => a.order - b.order);
      const processedGroups = new Set();
      sortedItems.forEach(item => {
        if (item.mode === 'superset') {
          if (!item.groupId || processedGroups.has(item.groupId)) return;
          const groupItems = sortedItems.filter(candidate => candidate.groupId === item.groupId);
          processedGroups.add(item.groupId);
          list.appendChild(buildSupersetCard(groupItems));
        } else {
          list.appendChild(buildSingleCard(item));
        }
      });
      container.appendChild(list);
    }

    function buildSingleCard(item) {
      const card = document.createElement('article');
      card.className = 'section-card bg-white p-5 space-y-4';
      const partLabel = state.master.parts.find(p => p.id === item.part)?.label ?? '';
      const header = document.createElement('div');
      header.className = 'flex items-start justify-between gap-3';
      header.innerHTML = `
        <div class="min-w-0">
          <p class="text-sm font-semibold text-slate-600 truncate">${item.exercise}</p>
          <p class="text-xs text-slate-400">${partLabel}</p>
        </div>
        <div class="text-xs text-slate-400 text-right min-w-0 truncate">
          ${[item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ')}
        </div>
      `;
      card.appendChild(header);
      if (item.attachment && item.attachment !== '-') {
        const att = document.createElement('p');
        att.className = 'text-[11px] text-slate-400';
        att.textContent = `アタッチメント: ${item.attachment}`;
        card.appendChild(att);
      }

      const badgeArea = document.createElement('div');
      badgeArea.className = 'flex flex-col gap-2';
      groupSetsForDisplay(item.sets).forEach(group => {
        const row = document.createElement('div');
        row.className = 'flex items-start gap-2';
        row.appendChild(createSetBadge(group.base, item));
        if (group.drops.length > 0) {
          const dropList = document.createElement('div');
          dropList.className = 'pl-6 flex flex-wrap gap-2';
          group.drops.forEach(drop => dropList.appendChild(createSetBadge(drop, item, true)));
          row.appendChild(dropList);
        }
        badgeArea.appendChild(row);
      });
      card.appendChild(badgeArea);

      const controls = document.createElement('div');
      controls.className = 'flex justify-end gap-3 pt-1';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'px-4 py-2 rounded-full bg-indigo-100 text-indigo-700 text-sm font-semibold min-h-[44px]';
      editBtn.textContent = '編集';
      editBtn.addEventListener('click', () => {
        uiState.currentItemId = item.id;
        prepareSetEditor(item.id);
        navigate('#/set');
      });
      controls.appendChild(editBtn);
      card.appendChild(controls);
      return card;
    }

    function buildSupersetCard(groupItems) {
      const sorted = [...groupItems].sort((a, b) => a.order - b.order);
      const labels = ['A', 'B', 'C'];
      const title = `(SS) ${sorted.map(item => item.exercise).join(' + ')}`;
      const card = document.createElement('article');
      card.className = 'section-card bg-white p-5 space-y-4';
      const header = document.createElement('div');
      header.className = 'flex items-start justify-between gap-3';
      header.innerHTML = `
        <div class="min-w-0">
          <p class="text-sm font-semibold text-slate-600 truncate">${title}</p>
          <p class="text-xs text-slate-400">${sorted.map((item, index) => `${labels[index]}. ${state.master.parts.find(p => p.id === item.part)?.label ?? ''}`).join(' / ')}</p>
        </div>
        <div class="text-xs text-slate-400 text-right min-w-0 truncate">
          ${sorted.map(item => [item.gear, item.angle, item.position].map(val => val && val !== '-' ? val : '―').join(' / ')).join(' ｜ ')}
        </div>
      `;
      card.appendChild(header);

      const rounds = buildSupersetRounds(sorted);
      if (rounds.length > 0) {
        const roundList = document.createElement('div');
        roundList.className = 'flex flex-col gap-2';
        rounds.forEach(round => {
          const row = document.createElement('div');
          row.className = 'flex flex-col gap-1';
          const badgeRow = document.createElement('div');
          badgeRow.className = 'flex flex-wrap gap-2 items-start';
          round.entries.forEach(entry => badgeRow.appendChild(entry));
          row.appendChild(badgeRow);
          if (round.drops.length > 0) {
            const dropRow = document.createElement('div');
            dropRow.className = 'pl-6 flex flex-wrap gap-2';
            round.drops.forEach(drop => dropRow.appendChild(drop));
            row.appendChild(dropRow);
          }
          roundList.appendChild(row);
        });
        card.appendChild(roundList);
      }

      const soloArea = document.createElement('div');
      const soloChips = [];
      sorted.forEach((item, index) => {
        const solos = groupSetsForDisplay(item.sets.filter(set => set.round == null));
        solos.forEach(group => {
          const row = document.createElement('div');
          row.className = 'flex items-start gap-2';
          const chip = createSetBadge(group.base, item);
          chip.textContent = `${labels[index]}: ${chip.textContent}`;
          row.appendChild(chip);
          if (group.drops.length > 0) {
            const dropList = document.createElement('div');
            dropList.className = 'pl-6 flex flex-wrap gap-2';
            group.drops.forEach(drop => dropList.appendChild(createSetBadge(drop, item, true)));
            row.appendChild(dropList);
          }
          soloChips.push(row);
        });
      });
      if (soloChips.length > 0) {
        const heading = document.createElement('p');
        heading.className = 'text-xs text-slate-400';
        heading.textContent = '単独セット';
        card.appendChild(heading);
        soloChips.forEach(row => card.appendChild(row));
      }

      const controls = document.createElement('div');
      controls.className = 'flex justify-end gap-3 pt-1';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'px-4 py-2 rounded-full bg-indigo-100 text-indigo-700 text-sm font-semibold min-h-[44px]';
      editBtn.textContent = '編集';
      editBtn.addEventListener('click', () => {
        uiState.currentItemId = sorted[0].id;
        prepareSetEditor(sorted[0].id);
        navigate('#/set');
      });
      controls.appendChild(editBtn);
      card.appendChild(controls);
      return card;
    }

    function buildSupersetRounds(groupItems) {
      const map = new Map();
      const labels = ['A', 'B', 'C'];
      groupItems.forEach((item, index) => {
        let currentBase = null;
        item.sets
          .filter(set => set.round !== null && set.round !== undefined)
          .sort((a, b) => a.ts - b.ts)
          .forEach(set => {
            if (!map.has(set.round)) {
              map.set(set.round, { entries: new Map(), drops: [] });
            }
            const slot = map.get(set.round);
            if (!set.drop) {
              currentBase = { item, set };
              slot.entries.set(labels[index], { item, set, drops: [] });
            } else if (currentBase && slot.entries.has(labels[index])) {
              slot.entries.get(labels[index]).drops.push({ item, set });
            } else {
              slot.drops.push(createSetBadge(set, item, true));
            }
          });
      });
      const rows = [];
      [...map.keys()].sort((a, b) => a - b).forEach(round => {
        const entry = map.get(round);
        const displayEntries = [];
        const dropBadges = [...entry.drops];
        groupItems.forEach((item, index) => {
          const label = labels[index];
          const data = entry.entries.get(label);
          if (data) {
            const chip = createSetBadge(data.set, data.item);
            chip.textContent = `${label}: ${chip.textContent}`;
            displayEntries.push(chip);
            data.drops.forEach(drop => {
              dropBadges.push(createSetBadge(drop.set, drop.item, true));
            });
          }
        });
        if (displayEntries.length > 0) {
          rows.push({ entries: displayEntries, drops: dropBadges });
        }
      });
      return rows;
    }

    function groupSetsForDisplay(sets) {
      const rows = [];
      let current = null;
      sets.forEach(set => {
        if (!set.drop) {
          current = { base: set, drops: [] };
          rows.push(current);
        } else if (current) {
          current.drops.push(set);
        } else {
          rows.push({ base: set, drops: [] });
        }
      });
      return rows;
    }

    function createSetBadge(set, item, isDrop = false) {
      const badge = document.createElement('span');
      const baseClasses = 'inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold min-h-[32px] truncate';
      const color = set.warmup ? 'bg-slate-200 text-slate-600' : 'bg-orange-100 text-orange-700';
      badge.className = `${baseClasses} ${isDrop ? 'border border-orange-200 bg-orange-50 text-orange-600' : color}`;
      badge.textContent = formatSetValue(set, item.timed);
      return badge;
    }

    function formatSetValue(set, timed) {
      if (timed) {
        return `${set.seconds ?? '-'}秒`;
      }
      const weight = set.weight != null ? `${set.weight}kg` : '-kg';
      const reps = set.repsU != null ? `${set.repsU}` : '-';
      const assist = set.repsA != null && set.repsA > 0 ? ` +${set.repsA}` : '';
      return `${weight}×${reps}${assist}`;
    }

    function renderExercise() {
      const container = document.querySelector('[data-route="#/exercise"]');
      container.innerHTML = '';

      const form = document.createElement('form');
      form.className = 'section-card bg-white p-6 space-y-6';
      form.innerHTML = `
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-semibold">種目入力</h2>
          <button type="button" id="exerciseBack" class="text-sm text-indigo-500 font-semibold px-3 py-2 min-h-[44px]">← 今日の一覧へ戻る</button>
        </div>
        <div class="flex items-center gap-3 bg-slate-100 rounded-2xl px-4 py-3 text-sm text-slate-600">
          <input type="checkbox" id="supersetToggle" class="w-5 h-5 rounded" ${uiState.exerciseForm.superset ? 'checked' : ''}>
          <label for="supersetToggle" class="font-semibold">スーパーセットにする</label>
        </div>
        <div id="exerciseCards" class="flex flex-col gap-4"></div>
        <div class="flex justify-between items-center">
          <button type="submit" class="ios-card bg-indigo-500 text-white px-6 py-3 font-semibold min-h-[44px]">決定</button>
        </div>
      `;
      container.appendChild(form);

      const cardsContainer = form.querySelector('#exerciseCards');
      renderExerciseCards(cardsContainer);

      form.addEventListener('change', event => {
        if (event.target.id === 'supersetToggle') {
          uiState.exerciseForm.superset = event.target.checked;
          if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length < 2) {
            uiState.exerciseForm.cards = [createExerciseCardState('A'), createExerciseCardState('B')];
          }
          if (!uiState.exerciseForm.superset) {
            uiState.exerciseForm.cards = [createExerciseCardState('A')];
          }
          renderExercise();
        }
      });

      form.addEventListener('submit', event => {
        event.preventDefault();
        const newItems = buildItemsFromExerciseForm();
        const baseOrder = Math.max(0, ...state.day.items.map(item => item.order)) + 1;
        newItems.forEach((item, index) => {
          item.order = item.mode === 'superset' ? baseOrder + index * 0.01 : baseOrder;
          state.day.items.push(item);
        });
        state.day.items.sort((a, b) => a.order - b.order);
        const firstId = newItems[0]?.id;
        if (firstId) {
          uiState.currentItemId = firstId;
          prepareSetEditor(firstId, true);
          navigate('#/set');
        } else {
          navigate('#/today');
        }
      });

      form.querySelector('#exerciseBack').addEventListener('click', () => navigate('#/today'));
    }

    function renderExerciseCards(container) {
      container.innerHTML = '';
      uiState.exerciseForm.cards.forEach((card, index) => {
        const cardEl = document.createElement('section');
        cardEl.className = 'bg-slate-50 rounded-2xl p-4 space-y-4 border border-slate-200';
        const label = uiState.exerciseForm.superset ? ['A', 'B', 'C'][index] : '';
        const title = uiState.exerciseForm.superset ? `${label} 種目` : '種目設定';
        cardEl.innerHTML = `
          <div class="flex items-center justify-between">
            <h3 class="text-sm font-semibold text-slate-600">${title}</h3>
            ${uiState.exerciseForm.superset && uiState.exerciseForm.cards.length > 2 && index === uiState.exerciseForm.cards.length - 1
              ? '<button type="button" class="text-xs text-rose-500 font-semibold" data-remove="true">削除</button>'
              : ''}
          </div>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <label class="flex flex-col gap-1 text-sm font-semibold text-slate-600">
              部位
              <select class="w-full rounded-2xl border border-slate-200 px-3 py-3 text-sm min-h-[44px]" data-field="part"></select>
            </label>
            <label class="flex flex-col gap-1 text-sm font-semibold text-slate-600">
              種目
              <select class="w-full rounded-2xl border border-slate-200 px-3 py-3 text-sm min-h-[44px]" data-field="exercise"></select>
            </label>
          </div>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <label class="flex flex-col gap-1 text-sm font-semibold text-slate-600">
              器具
              <select class="w-full rounded-2xl border border-slate-200 px-3 py-3 text-sm min-h-[44px]" data-field="gear"></select>
            </label>
            <label class="flex flex-col gap-1 text-sm font-semibold text-slate-600">
              アタッチメント
              <select class="w-full rounded-2xl border border-slate-200 px-3 py-3 text-sm min-h-[44px]" data-field="attachment"></select>
            </label>
          </div>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <label class="flex flex-col gap-1 text-sm font-semibold text-slate-600">
              角度
              <select class="w-full rounded-2xl border border-slate-200 px-3 py-3 text-sm min-h-[44px]" data-field="angle"></select>
            </label>
            <label class="flex flex-col gap-1 text-sm font-semibold text-slate-600">
              ポジション
              <select class="w-full rounded-2xl border border-slate-200 px-3 py-3 text-sm min-h-[44px]" data-field="position"></select>
            </label>
          </div>
          <div class="flex flex-wrap gap-3 text-sm text-slate-600">
            <label class="flex items-center gap-2 bg-white rounded-2xl px-4 py-3 min-h-[44px]">
              <input type="checkbox" class="w-5 h-5 rounded" data-field="timed" ${card.timed ? 'checked' : ''}>
              秒数で記録
            </label>
            <label class="flex items-center gap-2 bg-white rounded-2xl px-4 py-3 min-h-[44px]">
              <input type="checkbox" class="w-5 h-5 rounded" data-field="oneHand" ${card.oneHand ? 'checked' : ''}>
              ワンハンド
            </label>
          </div>
        `;
        container.appendChild(cardEl);

        const partSelect = cardEl.querySelector('[data-field="part"]');
        const exerciseSelect = cardEl.querySelector('[data-field="exercise"]');
        const selects = [
          { element: partSelect, field: 'part', options: state.master.parts.map(p => ({ value: p.id, label: p.label })) },
          { element: cardEl.querySelector('[data-field="gear"]'), field: 'gear', options: sortForDisplay(state.master.gear).map(value => ({ value, label: value })) },
          { element: cardEl.querySelector('[data-field="attachment"]'), field: 'attachment', options: sortForDisplay(state.master.attachments).map(value => ({ value, label: value })) },
          { element: cardEl.querySelector('[data-field="angle"]'), field: 'angle', options: sortForDisplay(state.master.angles).map(value => ({ value, label: value })) },
          { element: cardEl.querySelector('[data-field="position"]'), field: 'position', options: sortForDisplay(state.master.positions).map(value => ({ value, label: value })) }
        ];
        populateSelect(partSelect, selects[0].options, card.part);
        updateExerciseOptions(exerciseSelect, card);
        selects.slice(1).forEach(select => populateSelect(select.element, select.options, card[select.field]));

        cardEl.querySelectorAll('select, input[type="checkbox"]').forEach(field => {
          field.addEventListener('change', event => {
            const target = event.target;
            const fieldName = target.getAttribute('data-field');
            if (!fieldName) return;
            if (fieldName === 'part') {
              card.part = target.value;
              updateExerciseOptions(exerciseSelect, card);
            } else if (fieldName === 'exercise') {
              card.exercise = target.value;
            } else if (fieldName === 'timed' || fieldName === 'oneHand') {
              card[fieldName] = target.checked;
            } else {
              card[fieldName] = target.value;
            }
          });
        });

        if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length > 2 && index === uiState.exerciseForm.cards.length - 1) {
          cardEl.querySelector('[data-remove="true"]').addEventListener('click', () => {
            uiState.exerciseForm.cards.splice(index, 1);
            renderExercise();
          });
        }
      });

      if (uiState.exerciseForm.superset && uiState.exerciseForm.cards.length < 3) {
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'w-full text-sm text-indigo-500 font-semibold px-4 py-3 bg-white rounded-2xl border border-dashed border-indigo-200 min-h-[44px]';
        addBtn.textContent = '＋ カード追加';
        addBtn.addEventListener('click', () => {
          const label = ['A', 'B', 'C'][uiState.exerciseForm.cards.length] || 'C';
          uiState.exerciseForm.cards.push(createExerciseCardState(label));
          renderExercise();
        });
        container.appendChild(addBtn);
      }
    }

    function populateSelect(select, options, selected) {
      select.innerHTML = '';
      options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        if (option.value === selected) opt.selected = true;
        select.appendChild(opt);
      });
    }

    function updateExerciseOptions(select, card) {
      const exercises = sortForDisplay(state.master.exercises[card.part] || []);
      const actual = card.exercise && exercises.includes(card.exercise) ? card.exercise : exercises[0] || '';
      select.innerHTML = '';
      exercises.forEach(value => {
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = value;
        if (value === actual) opt.selected = true;
        select.appendChild(opt);
      });
      card.exercise = actual;
    }

    function buildItemsFromExerciseForm() {
      const idBase = Date.now();
      if (!uiState.exerciseForm.superset) {
        const card = uiState.exerciseForm.cards[0];
        return [buildItemFromCard(card, `${idBase}`)];
      }
      const groupId = createGroupId();
      return uiState.exerciseForm.cards.map((card, index) => buildItemFromCard(card, `${idBase}-${index}`, groupId));
    }

    function buildItemFromCard(card, keySeed, groupId = null) {
      return {
        id: createId('item'),
        order: state.day.items.length + 1,
        mode: groupId ? 'superset' : 'single',
        groupId,
        part: card.part,
        exercise: card.exercise,
        gear: card.gear,
        attachment: card.attachment,
        angle: card.angle,
        position: card.position,
        timed: card.timed,
        oneHand: card.oneHand,
        sets: []
      };
    }

    function prepareSetEditor(itemId, isNew = false) {
      const target = state.day.items.find(item => item.id === itemId);
      if (!target) return;
      let items = [];
      if (target.mode === 'superset' && target.groupId) {
        items = state.day.items.filter(item => item.groupId === target.groupId).sort((a, b) => a.order - b.order);
      } else {
        items = [target];
      }
      const editorItems = items.map((item, index) => ({
        itemId: item.id,
        label: ['A', 'B', 'C'][index] || 'A',
        timed: item.timed,
        mode: item.mode,
        rows: buildRowsFromSets(item.sets, item.timed)
      }));
      const maxRound = Math.max(-1, ...items.flatMap(item => item.sets.filter(set => set.round != null).map(set => set.round)));
      uiState.setEditor = {
        isSuperset: target.mode === 'superset',
        activeIndex: items.findIndex(item => item.id === itemId) || 0,
        items: editorItems,
        cycleBuffers: editorItems.map(item => createBuffer(item.timed)),
        nextRound: maxRound + 1,
        isNew
      };
    }

    function buildRowsFromSets(sets, timed) {
      const rows = [];
      let current = null;
      sets.sort((a, b) => a.ts - b.ts).forEach(set => {
        if (!set.drop) {
          current = createRowFromSet(set);
          rows.push(current);
        } else if (current) {
          current.drops.push(createDropFromSet(set));
        } else {
          const orphan = createRowFromSet(set);
          rows.push(orphan);
        }
      });
      if (rows.length === 0) {
        rows.push(createBlankRow(timed));
      }
      return rows;
    }

    function createRowFromSet(set) {
      return {
        id: set.id || createId('row'),
        weight: set.weight ?? '',
        repsU: set.repsU ?? '',
        repsA: set.repsA ?? '',
        seconds: set.seconds ?? '',
        warmup: !!set.warmup,
        round: set.round ?? null,
        drops: []
      };
    }

    function createDropFromSet(set) {
      return {
        id: set.id || createId('drop'),
        weight: set.weight ?? '',
        repsU: set.repsU ?? '',
        repsA: set.repsA ?? '',
        seconds: set.seconds ?? '',
        warmup: !!set.warmup,
        round: set.round ?? null
      };
    }

    function createBlankRow(timed, round = null) {
      return {
        id: createId('row'),
        weight: timed ? '' : '',
        repsU: '',
        repsA: '',
        seconds: timed ? '' : '',
        warmup: false,
        round,
        drops: []
      };
    }

    function createBlankDrop(timed, round = null) {
      return {
        id: createId('drop'),
        weight: timed ? '' : '',
        repsU: '',
        repsA: '',
        seconds: timed ? '' : '',
        warmup: false,
        round
      };
    }

    function createBuffer(timed) {
      return {
        row: createBlankRow(timed),
        drops: []
      };
    }

    function renderSet() {
      const container = document.querySelector('[data-route="#/set"]');
      container.innerHTML = '';
      const editor = uiState.setEditor;
      if (!editor) {
        const message = document.createElement('p');
        message.className = 'text-sm text-slate-500';
        message.textContent = '編集対象の種目が選択されていません。';
        container.appendChild(message);
        return;
      }
      const section = document.createElement('section');
      section.className = 'section-card bg-white p-6 space-y-6';

      if (editor.isSuperset) {
        const tabs = document.createElement('div');
        tabs.className = 'flex gap-2';
        editor.items.forEach((item, index) => {
          const tab = document.createElement('button');
          tab.type = 'button';
          tab.className = `flex-1 rounded-2xl px-4 py-2 text-sm font-semibold min-h-[44px] ${index === editor.activeIndex ? 'bg-indigo-500 text-white' : 'bg-slate-100 text-slate-600'}`;
          tab.textContent = item.label;
          tab.addEventListener('click', () => {
            editor.activeIndex = index;
            renderSet();
          });
          tabs.appendChild(tab);
        });
        section.appendChild(tabs);
      }

      const active = editor.items[editor.activeIndex];
      const item = state.day.items.find(it => it.id === active.itemId);
      if (!item) {
        container.appendChild(section);
        return;
      }

      const subtitle = [item.gear, item.attachment, item.angle, item.position]
        .map(value => (value && value !== '-') ? value : '―')
        .join(' / ');
      const header = document.createElement('div');
      header.innerHTML = `
        <div>
          <h2 class="text-xl font-semibold">${item.exercise}</h2>
          <p class="text-[11px] text-slate-400 mt-1">${subtitle}</p>
        </div>
      `;
      section.appendChild(header);

      const rowsWrapper = document.createElement('div');
      rowsWrapper.className = 'space-y-4';
      active.rows.forEach((row, rowIndex) => {
        const rowCard = document.createElement('div');
        rowCard.className = 'bg-slate-50 rounded-2xl p-4 space-y-4 border border-slate-200';
        const title = document.createElement('div');
        title.className = 'flex items-center justify-between text-xs text-slate-500';
        title.textContent = row.round != null ? `ラウンド ${row.round}` : '単独セット';
        rowCard.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-slate-600';
        if (active.timed) {
          grid.appendChild(createNumberInput('秒数', row.seconds, value => { row.seconds = value; }));
        } else {
          grid.appendChild(createNumberInput('重量(kg)', row.weight, value => { row.weight = value; }));
          grid.appendChild(createNumberInput('自力レップ', row.repsU, value => { row.repsU = value; }));
          grid.appendChild(createNumberInput('補助レップ', row.repsA, value => { row.repsA = value; }, 0));
        }
        rowCard.appendChild(grid);

        const toggles = document.createElement('div');
        toggles.className = 'flex flex-wrap gap-3 text-sm text-slate-600';
        const warmupLabel = document.createElement('label');
        warmupLabel.className = 'flex items-center gap-2 bg-white rounded-2xl px-4 py-2 min-h-[40px]';
        const warmupInput = document.createElement('input');
        warmupInput.type = 'checkbox';
        warmupInput.className = 'w-5 h-5 rounded';
        warmupInput.checked = row.warmup;
        warmupInput.addEventListener('change', () => { row.warmup = warmupInput.checked; });
        warmupLabel.append(warmupInput, document.createTextNode('ウォームアップ'));
        toggles.appendChild(warmupLabel);
        rowCard.appendChild(toggles);

        const dropArea = document.createElement('div');
        dropArea.className = 'space-y-3';
        row.drops.forEach((drop, dropIndex) => {
          const dropCard = document.createElement('div');
          dropCard.className = 'bg-white rounded-2xl p-4 space-y-3 border border-dashed border-orange-200';
          const dropTitle = document.createElement('p');
          dropTitle.className = 'text-xs font-semibold text-orange-600';
          dropTitle.textContent = 'ドロップセット';
          dropCard.appendChild(dropTitle);
          const dropGrid = document.createElement('div');
          dropGrid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-slate-600';
          if (active.timed) {
            dropGrid.appendChild(createNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
          } else {
            dropGrid.appendChild(createNumberInput('重量(kg)', drop.weight, value => { drop.weight = value; }));
            dropGrid.appendChild(createNumberInput('自力レップ', drop.repsU, value => { drop.repsU = value; }));
            dropGrid.appendChild(createNumberInput('補助レップ', drop.repsA, value => { drop.repsA = value; }, 0));
          }
          dropCard.appendChild(dropGrid);
          const dropToggle = document.createElement('label');
          dropToggle.className = 'inline-flex items-center gap-2 bg-slate-100 rounded-2xl px-3 py-2 text-xs text-slate-600 min-h-[32px]';
          const dropWarm = document.createElement('input');
          dropWarm.type = 'checkbox';
          dropWarm.className = 'w-4 h-4 rounded';
          dropWarm.checked = drop.warmup;
          dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; });
          dropToggle.append(dropWarm, document.createTextNode('ウォームアップ'));
          dropCard.appendChild(dropToggle);
          const dropFooter = document.createElement('div');
          dropFooter.className = 'flex justify-end';
          const dropRemove = document.createElement('button');
          dropRemove.type = 'button';
          dropRemove.className = 'text-xs text-rose-500 font-semibold px-3 py-1 min-h-[32px]';
          dropRemove.textContent = '削除';
          dropRemove.addEventListener('click', () => {
            row.drops.splice(dropIndex, 1);
            renderSet();
          });
          dropFooter.appendChild(dropRemove);
          dropCard.appendChild(dropFooter);
          dropArea.appendChild(dropCard);
        });
        const addDropBtn = document.createElement('button');
        addDropBtn.type = 'button';
        addDropBtn.className = 'w-full text-xs text-indigo-500 font-semibold px-4 py-2 bg-white rounded-2xl min-h-[40px]';
        addDropBtn.textContent = '＋ ドロップセット';
        addDropBtn.addEventListener('click', () => {
          row.drops.push(createBlankDrop(active.timed, row.round));
          renderSet();
        });
        dropArea.appendChild(addDropBtn);
        rowCard.appendChild(dropArea);

        const rowFooter = document.createElement('div');
        rowFooter.className = 'flex justify-end';
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'text-sm text-rose-500 font-semibold px-4 py-2 min-h-[44px]';
        removeBtn.textContent = 'このセットを削除';
        removeBtn.addEventListener('click', () => {
          active.rows.splice(rowIndex, 1);
          if (active.rows.length === 0) {
            active.rows.push(createBlankRow(active.timed));
          }
          renderSet();
        });
        rowFooter.appendChild(removeBtn);
        rowCard.appendChild(rowFooter);

        rowsWrapper.appendChild(rowCard);
      });
      section.appendChild(rowsWrapper);

      const addSetBtn = document.createElement('button');
      addSetBtn.type = 'button';
      addSetBtn.className = 'w-full text-sm text-indigo-500 font-semibold px-4 py-3 bg-white rounded-2xl min-h-[44px]';
      addSetBtn.textContent = editor.isSuperset ? '＋ 単独セット追加' : '＋ セット追加';
      addSetBtn.addEventListener('click', () => {
        active.rows.push(createBlankRow(active.timed));
        renderSet();
      });
      section.appendChild(addSetBtn);

      if (editor.isSuperset) {
        section.appendChild(renderRoundBuffer(editor));
      }

      const footer = document.createElement('div');
      footer.className = 'flex flex-col sm:flex-row gap-3 justify-between';
      const saveBack = document.createElement('button');
      saveBack.type = 'button';
      saveBack.className = 'ios-card bg-indigo-500 text-white px-6 py-3 font-semibold min-h-[44px]';
      saveBack.textContent = '保存して戻る';
      saveBack.addEventListener('click', () => {
        persistSetEditor();
        navigate('#/today');
      });
      const saveNext = document.createElement('button');
      saveNext.type = 'button';
      saveNext.className = 'ios-card bg-white text-indigo-600 px-6 py-3 font-semibold min-h-[44px]';
      saveNext.textContent = '次の種目へ';
      saveNext.addEventListener('click', () => {
        persistSetEditor();
        uiState.exerciseForm = createExerciseFormState();
        navigate('#/exercise');
      });
      footer.append(saveBack, saveNext);
      section.appendChild(footer);

      container.appendChild(section);
    }

    function renderRoundBuffer(editor) {
      const wrapper = document.createElement('div');
      wrapper.className = 'space-y-4 bg-indigo-50 rounded-2xl p-4 border border-indigo-200';
      const title = document.createElement('div');
      title.className = 'flex items-center justify-between';
      title.innerHTML = `
        <div>
          <p class="text-sm font-semibold text-indigo-700">ラウンド入力</p>
          <p class="text-xs text-indigo-500">現在のラウンド番号: ${editor.nextRound}</p>
        </div>
        <button type="button" class="ios-card bg-indigo-500 text-white px-4 py-2 text-sm font-semibold min-h-[40px]" id="nextRoundBtn">次ラウンドへ</button>
      `;
      wrapper.appendChild(title);
      const activeBuffer = editor.cycleBuffers[editor.activeIndex];
      const activeItem = editor.items[editor.activeIndex];
      const grid = document.createElement('div');
      grid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-indigo-700';
      if (activeItem.timed) {
        grid.appendChild(createNumberInput('秒数', activeBuffer.row.seconds, value => { activeBuffer.row.seconds = value; }));
      } else {
        grid.appendChild(createNumberInput('重量(kg)', activeBuffer.row.weight, value => { activeBuffer.row.weight = value; }));
        grid.appendChild(createNumberInput('自力レップ', activeBuffer.row.repsU, value => { activeBuffer.row.repsU = value; }));
        grid.appendChild(createNumberInput('補助レップ', activeBuffer.row.repsA, value => { activeBuffer.row.repsA = value; }, 0));
      }
      wrapper.appendChild(grid);
      const warmupRow = document.createElement('label');
      warmupRow.className = 'inline-flex items-center gap-2 bg-white rounded-2xl px-3 py-2 text-xs text-indigo-700 min-h-[32px]';
      const warmupInput = document.createElement('input');
      warmupInput.type = 'checkbox';
      warmupInput.className = 'w-4 h-4 rounded';
      warmupInput.checked = activeBuffer.row.warmup;
      warmupInput.addEventListener('change', () => { activeBuffer.row.warmup = warmupInput.checked; });
      warmupRow.append(warmupInput, document.createTextNode('ウォームアップ'));
      wrapper.appendChild(warmupRow);

      activeBuffer.drops.forEach((drop, index) => {
        const dropCard = document.createElement('div');
        dropCard.className = 'bg-white rounded-2xl p-4 space-y-3 border border-dashed border-indigo-200';
        const dropTitle = document.createElement('p');
        dropTitle.className = 'text-xs font-semibold text-indigo-600';
        dropTitle.textContent = 'ドロップセット';
        dropCard.appendChild(dropTitle);
        const dropGrid = document.createElement('div');
        dropGrid.className = 'grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm text-indigo-700';
        if (activeItem.timed) {
          dropGrid.appendChild(createNumberInput('秒数', drop.seconds, value => { drop.seconds = value; }));
        } else {
          dropGrid.appendChild(createNumberInput('重量(kg)', drop.weight, value => { drop.weight = value; }));
          dropGrid.appendChild(createNumberInput('自力レップ', drop.repsU, value => { drop.repsU = value; }));
          dropGrid.appendChild(createNumberInput('補助レップ', drop.repsA, value => { drop.repsA = value; }, 0));
        }
        dropCard.appendChild(dropGrid);
        const dropToggle = document.createElement('label');
        dropToggle.className = 'inline-flex items-center gap-2 bg-slate-100 rounded-2xl px-3 py-2 text-xs text-slate-600 min-h-[32px]';
        const dropWarm = document.createElement('input');
        dropWarm.type = 'checkbox';
        dropWarm.className = 'w-4 h-4 rounded';
        dropWarm.checked = drop.warmup;
        dropWarm.addEventListener('change', () => { drop.warmup = dropWarm.checked; });
        dropToggle.append(dropWarm, document.createTextNode('ウォームアップ'));
        dropCard.appendChild(dropToggle);
        const dropFooter = document.createElement('div');
        dropFooter.className = 'flex justify-end';
        const dropRemove = document.createElement('button');
        dropRemove.type = 'button';
        dropRemove.className = 'text-xs text-rose-500 font-semibold px-3 py-1 min-h-[32px]';
        dropRemove.textContent = '削除';
        dropRemove.addEventListener('click', () => {
          activeBuffer.drops.splice(index, 1);
          renderSet();
        });
        dropFooter.appendChild(dropRemove);
        dropCard.appendChild(dropFooter);
        wrapper.appendChild(dropCard);
      });

      const addDropBtn = document.createElement('button');
      addDropBtn.type = 'button';
      addDropBtn.className = 'w-full text-xs text-indigo-500 font-semibold px-4 py-2 bg-white rounded-2xl min-h-[40px]';
      addDropBtn.textContent = '＋ ドロップセット';
      addDropBtn.addEventListener('click', () => {
        activeBuffer.drops.push(createBlankDrop(activeItem.timed));
        renderSet();
      });
      wrapper.appendChild(addDropBtn);

      wrapper.querySelector('#nextRoundBtn').addEventListener('click', () => {
        advanceRoundCycle();
      });

      return wrapper;
    }

    function createNumberInput(labelText, value, onInput, min = 0) {
      const wrapper = document.createElement('label');
      wrapper.className = 'flex flex-col gap-1';
      wrapper.innerHTML = `<span>${labelText}</span>`;
      const input = document.createElement('input');
      input.type = 'number';
      input.min = String(min);
      input.value = value ?? '';
      input.className = 'rounded-2xl border border-slate-200 px-3 py-2';
      input.addEventListener('input', () => onInput(input.value));
      wrapper.appendChild(input);
      return wrapper;
    }

    function bufferHasData(buffer, timed) {
      if (timed) {
        return buffer.row.seconds !== '' || buffer.drops.some(drop => drop.seconds !== '');
      }
      const baseFilled = buffer.row.weight !== '' || buffer.row.repsU !== '' || buffer.row.repsA !== '';
      const dropFilled = buffer.drops.some(drop => drop.weight !== '' || drop.repsU !== '' || drop.repsA !== '');
      return baseFilled || dropFilled;
    }

    function advanceRoundCycle() {
      const editor = uiState.setEditor;
      if (!editor || !editor.isSuperset) return;
      const buffer = editor.cycleBuffers[editor.activeIndex];
      editor.activeIndex = (editor.activeIndex + 1) % editor.items.length;
      if (editor.activeIndex === 0) {
        finalizeRoundBuffer();
      } else {
        renderSet();
      }
    }

    function finalizeRoundBuffer() {
      const editor = uiState.setEditor;
      if (!editor) return;
      const entries = editor.cycleBuffers.map((buffer, index) => {
        const item = editor.items[index];
        if (!bufferHasData(buffer, item.timed)) return null;
        const row = createBlankRow(item.timed, editor.nextRound);
        row.weight = buffer.row.weight;
        row.repsU = buffer.row.repsU;
        row.repsA = buffer.row.repsA;
        row.seconds = buffer.row.seconds;
        row.warmup = buffer.row.warmup;
        row.drops = buffer.drops.map(drop => ({
          id: createId('drop'),
          weight: drop.weight,
          repsU: drop.repsU,
          repsA: drop.repsA,
          seconds: drop.seconds,
          warmup: drop.warmup,
          round: editor.nextRound
        }));
        return row;
      });
      const hasAny = entries.some(entry => entry !== null);
      if (hasAny) {
        entries.forEach((row, index) => {
          if (!row) return;
          editor.items[index].rows.push(row);
        });
        editor.nextRound += 1;
      }
      editor.cycleBuffers = editor.items.map(item => createBuffer(item.timed));
      renderSet();
    }

    function persistSetEditor() {
      const editor = uiState.setEditor;
      if (!editor) return;
      editor.items.forEach(itemState => {
        const item = state.day.items.find(it => it.id === itemState.itemId);
        if (!item) return;
        const newSets = [];
        itemState.rows.forEach(row => {
          const built = buildSetsFromRow(row, itemState.timed);
          built.forEach(set => newSets.push(set));
        });
        item.sets = newSets;
      });
      state.day.items.sort((a, b) => a.order - b.order).forEach((entry, index) => {
        entry.order = index + 1;
      });
      renderToday();
    }

    function buildSetsFromRow(row, timed) {
      const sets = [];
      const base = convertRowToSet(row, timed, false);
      if (base) sets.push(base);
      row.drops.forEach(drop => {
        const dropSet = convertRowToSet({ ...drop, round: drop.round ?? row.round }, timed, true);
        if (dropSet) sets.push(dropSet);
      });
      return sets;
    }

    function convertRowToSet(row, timed, isDrop) {
      if (timed) {
        const seconds = parseNumber(row.seconds);
        if (seconds == null) return null;
        return createSet({ seconds, warmup: !!row.warmup, drop: isDrop, round: row.round ?? null });
      }
      const weight = parseNumber(row.weight);
      const repsU = parseNumber(row.repsU);
      const repsA = parseNumber(row.repsA);
      if (weight == null && repsU == null && repsA == null) return null;
      return createSet({ weight, repsU, repsA, warmup: !!row.warmup, drop: isDrop, round: row.round ?? null });
    }

    function parseNumber(value) {
      if (value === '' || value === null || value === undefined) return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    }

    function initialize() {
      handleNavigation(window.location.hash || '#/dashboard');
    }

    initialize();
  </script>
</body>
</html>
